---
description: PWA ê¸°ëŠ¥ ë° í‘¸ì‹œ ì•Œë¦¼ ì‹œìŠ¤í…œ êµ¬í˜„ ê°€ì´ë“œ
globs:
  - "frontend/public/sw.js"
  - "frontend/src/**/*notification*"
  - "frontend/src/**/*pwa*"
alwaysApply: true
---

# PWA ë° í‘¸ì‹œ ì•Œë¦¼ ì‹œìŠ¤í…œ

## PWA ê¸°ë³¸ ì„¤ì •

### 1. Web App Manifest

```json
// frontend/public/manifest.json
{
  "name": "Bible Daily - ì„±ê²½ë§ì”€ ì†Œê° ê³µìœ ",
  "short_name": "Bible Daily",
  "description": "ì¤‘ê³ ë“±í•™ìƒì„ ìœ„í•œ ì„±ê²½ë§ì”€ ì†Œê° ê³µìœ  í”Œë«í¼",
  "start_url": "/",
  "display": "standalone",
  "background_color": "#ffffff",
  "theme_color": "#f97316",
  "orientation": "portrait-primary",
  "categories": ["education", "lifestyle", "social"],
  "lang": "ko",
  "icons": [
    {
      "src": "/icons/icon-72x72.png",
      "sizes": "72x72",
      "type": "image/png",
      "purpose": "maskable any"
    },
    {
      "src": "/icons/icon-96x96.png",
      "sizes": "96x96",
      "type": "image/png",
      "purpose": "maskable any"
    },
    {
      "src": "/icons/icon-128x128.png",
      "sizes": "128x128",
      "type": "image/png",
      "purpose": "maskable any"
    },
    {
      "src": "/icons/icon-144x144.png",
      "sizes": "144x144",
      "type": "image/png",
      "purpose": "maskable any"
    },
    {
      "src": "/icons/icon-152x152.png",
      "sizes": "152x152",
      "type": "image/png",
      "purpose": "maskable any"
    },
    {
      "src": "/icons/icon-192x192.png",
      "sizes": "192x192",
      "type": "image/png",
      "purpose": "maskable any"
    },
    {
      "src": "/icons/icon-384x384.png",
      "sizes": "384x384",
      "type": "image/png",
      "purpose": "maskable any"
    },
    {
      "src": "/icons/icon-512x512.png",
      "sizes": "512x512",
      "type": "image/png",
      "purpose": "maskable any"
    }
  ],
  "shortcuts": [
    {
      "name": "ì˜¤ëŠ˜ì˜ ë¯¸ì…˜",
      "short_name": "ë¯¸ì…˜",
      "description": "ì˜¤ëŠ˜ì˜ ì„±ê²½ ì½ê¸° ë¯¸ì…˜ í™•ì¸",
      "url": "/missions/today",
      "icons": [{ "src": "/icons/shortcut-mission.png", "sizes": "96x96" }]
    },
    {
      "name": "ì†Œê° ì‘ì„±",
      "short_name": "ì†Œê°",
      "description": "ìƒˆë¡œìš´ ì†Œê° ì‘ì„±í•˜ê¸°",
      "url": "/posts/new",
      "icons": [{ "src": "/icons/shortcut-post.png", "sizes": "96x96" }]
    }
  ]
}
```

### 2. Service Worker ê¸°ë³¸ êµ¬ì¡°

```javascript
// frontend/public/sw.js
const CACHE_NAME = "bible-daily-v1";
const urlsToCache = [
  "/",
  "/static/js/bundle.js",
  "/static/css/main.css",
  "/manifest.json",
  "/icons/icon-192x192.png",
  "/icons/icon-512x512.png",
];

// ì„¤ì¹˜ ì´ë²¤íŠ¸
self.addEventListener("install", (event) => {
  event.waitUntil(
    caches.open(CACHE_NAME).then((cache) => {
      console.log("Opened cache");
      return cache.addAll(urlsToCache);
    })
  );
});

// í™œì„±í™” ì´ë²¤íŠ¸
self.addEventListener("activate", (event) => {
  event.waitUntil(
    caches.keys().then((cacheNames) => {
      return Promise.all(
        cacheNames.map((cacheName) => {
          if (cacheName !== CACHE_NAME) {
            console.log("Deleting old cache:", cacheName);
            return caches.delete(cacheName);
          }
        })
      );
    })
  );
});

// ë„¤íŠ¸ì›Œí¬ ìš”ì²­ ê°€ë¡œì±„ê¸°
self.addEventListener("fetch", (event) => {
  event.respondWith(
    caches.match(event.request).then((response) => {
      // ìºì‹œì— ìˆìœ¼ë©´ ìºì‹œì—ì„œ ë°˜í™˜
      if (response) {
        return response;
      }

      // ë„¤íŠ¸ì›Œí¬ì—ì„œ ê°€ì ¸ì˜¤ê¸°
      return fetch(event.request).then((response) => {
        // ìœ íš¨í•œ ì‘ë‹µì¸ì§€ í™•ì¸
        if (!response || response.status !== 200 || response.type !== "basic") {
          return response;
        }

        // ì‘ë‹µ ë³µì‚¬ (ìŠ¤íŠ¸ë¦¼ì€ í•œ ë²ˆë§Œ ì‚¬ìš© ê°€ëŠ¥)
        const responseToCache = response.clone();

        caches.open(CACHE_NAME).then((cache) => {
          cache.put(event.request, responseToCache);
        });

        return response;
      });
    })
  );
});

// í‘¸ì‹œ ì•Œë¦¼ ìˆ˜ì‹ 
self.addEventListener("push", (event) => {
  console.log("Push event received:", event);

  const options = {
    body: "Bible Dailyì—ì„œ ìƒˆë¡œìš´ ì•Œë¦¼ì´ ìˆìŠµë‹ˆë‹¤.",
    icon: "/icons/icon-192x192.png",
    badge: "/icons/badge-72x72.png",
    vibrate: [100, 50, 100],
    data: {
      dateOfArrival: Date.now(),
      primaryKey: 1,
    },
    actions: [
      {
        action: "explore",
        title: "í™•ì¸í•˜ê¸°",
        icon: "/icons/checkmark.png",
      },
      {
        action: "close",
        title: "ë‹«ê¸°",
        icon: "/icons/xmark.png",
      },
    ],
  };

  if (event.data) {
    const data = event.data.json();
    options.body = data.body || options.body;
    options.title = data.title || "Bible Daily";
    options.data = { ...options.data, ...data };
  }

  event.waitUntil(self.registration.showNotification("Bible Daily", options));
});

// ì•Œë¦¼ í´ë¦­ ì²˜ë¦¬
self.addEventListener("notificationclick", (event) => {
  console.log("Notification click received:", event);

  event.notification.close();

  if (event.action === "explore") {
    // ì•± ì—´ê¸° ë˜ëŠ” í¬ì»¤ìŠ¤
    event.waitUntil(clients.openWindow("/"));
  } else if (event.action === "close") {
    // ì•Œë¦¼ë§Œ ë‹«ê¸°
    return;
  } else {
    // ê¸°ë³¸ ë™ì‘: ì•± ì—´ê¸°
    event.waitUntil(clients.openWindow("/"));
  }
});

// ë°±ê·¸ë¼ìš´ë“œ ë™ê¸°í™”
self.addEventListener("sync", (event) => {
  if (event.tag === "background-sync") {
    event.waitUntil(doBackgroundSync());
  }
});

async function doBackgroundSync() {
  // ì˜¤í”„ë¼ì¸ ìƒíƒœì—ì„œ ì €ì¥ëœ ë°ì´í„° ë™ê¸°í™”
  console.log("Background sync triggered");
}
```

### 3. PWA ì„¤ì¹˜ í”„ë¡¬í”„íŠ¸

```typescript
// hooks/usePWAInstall.ts
export function usePWAInstall() {
  const [deferredPrompt, setDeferredPrompt] = useState<any>(null);
  const [isInstallable, setIsInstallable] = useState(false);
  const [isInstalled, setIsInstalled] = useState(false);

  useEffect(() => {
    // PWA ì„¤ì¹˜ ê°€ëŠ¥ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
    const handleBeforeInstallPrompt = (e: Event) => {
      e.preventDefault();
      setDeferredPrompt(e);
      setIsInstallable(true);
    };

    // PWA ì„¤ì¹˜ ì™„ë£Œ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
    const handleAppInstalled = () => {
      setIsInstalled(true);
      setIsInstallable(false);
      setDeferredPrompt(null);
    };

    window.addEventListener("beforeinstallprompt", handleBeforeInstallPrompt);
    window.addEventListener("appinstalled", handleAppInstalled);

    // ì´ë¯¸ ì„¤ì¹˜ë˜ì—ˆëŠ”ì§€ í™•ì¸
    if (window.matchMedia("(display-mode: standalone)").matches) {
      setIsInstalled(true);
    }

    return () => {
      window.removeEventListener(
        "beforeinstallprompt",
        handleBeforeInstallPrompt
      );
      window.removeEventListener("appinstalled", handleAppInstalled);
    };
  }, []);

  const installPWA = async () => {
    if (!deferredPrompt) return false;

    deferredPrompt.prompt();
    const { outcome } = await deferredPrompt.userChoice;

    if (outcome === "accepted") {
      setDeferredPrompt(null);
      setIsInstallable(false);
      return true;
    }

    return false;
  };

  return {
    isInstallable,
    isInstalled,
    installPWA,
  };
}

// ì„¤ì¹˜ í”„ë¡¬í”„íŠ¸ ì»´í¬ë„ŒíŠ¸
export function PWAInstallPrompt() {
  const { isInstallable, installPWA } = usePWAInstall();
  const [showPrompt, setShowPrompt] = useState(false);

  useEffect(() => {
    if (isInstallable) {
      // 3ì´ˆ í›„ì— í”„ë¡¬í”„íŠ¸ í‘œì‹œ
      const timer = setTimeout(() => setShowPrompt(true), 3000);
      return () => clearTimeout(timer);
    }
  }, [isInstallable]);

  if (!showPrompt || !isInstallable) return null;

  return (
    <div className="fixed bottom-20 left-4 right-4 bg-primary text-primary-foreground p-4 rounded-lg shadow-lg z-50">
      <div className="flex items-center justify-between">
        <div>
          <h3 className="font-semibold">ì•±ìœ¼ë¡œ ì„¤ì¹˜í•˜ê¸°</h3>
          <p className="text-sm opacity-90">ë” ë¹ ë¥´ê³  í¸ë¦¬í•˜ê²Œ ì´ìš©í•˜ì„¸ìš”!</p>
        </div>
        <div className="flex gap-2">
          <Button
            variant="secondary"
            size="sm"
            onClick={() => setShowPrompt(false)}
          >
            ë‚˜ì¤‘ì—
          </Button>
          <Button
            variant="secondary"
            size="sm"
            onClick={async () => {
              const success = await installPWA();
              if (success) setShowPrompt(false);
            }}
          >
            ì„¤ì¹˜
          </Button>
        </div>
      </div>
    </div>
  );
}
```

## í‘¸ì‹œ ì•Œë¦¼ ì‹œìŠ¤í…œ

### 1. ì•Œë¦¼ ê¶Œí•œ ê´€ë¦¬

```typescript
// hooks/useNotificationPermission.ts
export function useNotificationPermission() {
  const [permission, setPermission] =
    useState<NotificationPermission>("default");
  const [isSupported, setIsSupported] = useState(false);

  useEffect(() => {
    setIsSupported("Notification" in window && "serviceWorker" in navigator);

    if (isSupported) {
      setPermission(Notification.permission);
    }
  }, [isSupported]);

  const requestPermission = async (): Promise<boolean> => {
    if (!isSupported) return false;

    try {
      const result = await Notification.requestPermission();
      setPermission(result);
      return result === "granted";
    } catch (error) {
      console.error("ì•Œë¦¼ ê¶Œí•œ ìš”ì²­ ì‹¤íŒ¨:", error);
      return false;
    }
  };

  return {
    permission,
    isSupported,
    isGranted: permission === "granted",
    isDenied: permission === "denied",
    requestPermission,
  };
}
```

### 2. í‘¸ì‹œ êµ¬ë… ê´€ë¦¬

```typescript
// hooks/usePushSubscription.ts
export function usePushSubscription() {
  const [subscription, setSubscription] = useState<PushSubscription | null>(
    null
  );
  const [isLoading, setIsLoading] = useState(false);

  const subscribe = async (): Promise<PushSubscription | null> => {
    if (!("serviceWorker" in navigator) || !("PushManager" in window)) {
      console.error("Push messaging is not supported");
      return null;
    }

    setIsLoading(true);

    try {
      const registration = await navigator.serviceWorker.ready;

      const subscription = await registration.pushManager.subscribe({
        userVisibleOnly: true,
        applicationServerKey: urlBase64ToUint8Array(
          process.env.REACT_APP_VAPID_PUBLIC_KEY!
        ),
      });

      setSubscription(subscription);

      // ì„œë²„ì— êµ¬ë… ì •ë³´ ì „ì†¡
      await api.post("/notifications/subscribe", {
        subscription: subscription.toJSON(),
      });

      return subscription;
    } catch (error) {
      console.error("Push subscription failed:", error);
      return null;
    } finally {
      setIsLoading(false);
    }
  };

  const unsubscribe = async (): Promise<boolean> => {
    if (!subscription) return false;

    setIsLoading(true);

    try {
      await subscription.unsubscribe();

      // ì„œë²„ì—ì„œ êµ¬ë… ì •ë³´ ì œê±°
      await api.delete("/notifications/unsubscribe", {
        data: { endpoint: subscription.endpoint },
      });

      setSubscription(null);
      return true;
    } catch (error) {
      console.error("Push unsubscription failed:", error);
      return false;
    } finally {
      setIsLoading(false);
    }
  };

  useEffect(() => {
    // ê¸°ì¡´ êµ¬ë… í™•ì¸
    const checkExistingSubscription = async () => {
      if ("serviceWorker" in navigator) {
        const registration = await navigator.serviceWorker.ready;
        const existingSubscription =
          await registration.pushManager.getSubscription();
        setSubscription(existingSubscription);
      }
    };

    checkExistingSubscription();
  }, []);

  return {
    subscription,
    isLoading,
    isSubscribed: !!subscription,
    subscribe,
    unsubscribe,
  };
}

// VAPID í‚¤ ë³€í™˜ ìœ í‹¸ë¦¬í‹°
function urlBase64ToUint8Array(base64String: string): Uint8Array {
  const padding = "=".repeat((4 - (base64String.length % 4)) % 4);
  const base64 = (base64String + padding).replace(/-/g, "+").replace(/_/g, "/");

  const rawData = window.atob(base64);
  const outputArray = new Uint8Array(rawData.length);

  for (let i = 0; i < rawData.length; ++i) {
    outputArray[i] = rawData.charCodeAt(i);
  }
  return outputArray;
}
```

### 3. ë¡œì»¬ ì•Œë¦¼ ì‹œìŠ¤í…œ

```typescript
// hooks/useLocalNotifications.ts
export function useLocalNotifications() {
  const { isGranted } = useNotificationPermission();

  const scheduleNotification = (
    title: string,
    options: NotificationOptions & { delay?: number } = {}
  ) => {
    if (!isGranted) return;

    const { delay = 0, ...notificationOptions } = options;

    setTimeout(() => {
      new Notification(title, {
        icon: "/icons/icon-192x192.png",
        badge: "/icons/badge-72x72.png",
        ...notificationOptions,
      });
    }, delay);
  };

  const scheduleDailyReminder = (time: string) => {
    const [hours, minutes] = time.split(":").map(Number);
    const now = new Date();
    const scheduledTime = new Date();
    scheduledTime.setHours(hours, minutes, 0, 0);

    // ì˜¤ëŠ˜ ì‹œê°„ì´ ì§€ë‚¬ìœ¼ë©´ ë‚´ì¼ë¡œ ì„¤ì •
    if (scheduledTime <= now) {
      scheduledTime.setDate(scheduledTime.getDate() + 1);
    }

    const delay = scheduledTime.getTime() - now.getTime();

    setTimeout(() => {
      scheduleNotification("ì„±ê²½ ì½ê¸° ì‹œê°„ì…ë‹ˆë‹¤! ğŸ“–", {
        body: "ì˜¤ëŠ˜ì˜ ë§ì”€ì„ ì½ê³  ì†Œê°ì„ ë‚˜ëˆ„ì–´ë³´ì„¸ìš”.",
        tag: "daily-reminder",
        requireInteraction: true,
      });

      // ë‹¤ìŒ ë‚ ì„ ìœ„í•´ ë‹¤ì‹œ ìŠ¤ì¼€ì¤„ë§
      scheduleDailyReminder(time);
    }, delay);
  };

  return {
    scheduleNotification,
    scheduleDailyReminder,
  };
}
```

### 4. ì•Œë¦¼ ì„¤ì • ì»´í¬ë„ŒíŠ¸

```typescript
// components/NotificationSettings.tsx
interface NotificationSettingsProps {}

export function NotificationSettings({}: NotificationSettingsProps) {
  const { permission, isGranted, requestPermission } =
    useNotificationPermission();
  const { isSubscribed, subscribe, unsubscribe } = usePushSubscription();
  const { scheduleDailyReminder } = useLocalNotifications();

  const [settings, setSettings] = useState({
    dailyReminder: true,
    reminderTime: "20:00",
    newMission: true,
    cellMessages: true,
    postLikes: true,
    weeklyReport: true,
  });

  const handlePermissionRequest = async () => {
    const granted = await requestPermission();
    if (granted && !isSubscribed) {
      await subscribe();
    }
  };

  const handleSettingChange = (
    key: keyof typeof settings,
    value: boolean | string
  ) => {
    setSettings((prev) => ({ ...prev, [key]: value }));

    // ì¼ì¼ ì•Œë¦¼ ì‹œê°„ ë³€ê²½ ì‹œ ìŠ¤ì¼€ì¤„ ì—…ë°ì´íŠ¸
    if (key === "reminderTime" && settings.dailyReminder) {
      scheduleDailyReminder(value as string);
    }
  };

  return (
    <Card>
      <CardHeader>
        <CardTitle>ì•Œë¦¼ ì„¤ì •</CardTitle>
        <CardDescription>
          ì›í•˜ëŠ” ì•Œë¦¼ì„ ì„¤ì •í•˜ì—¬ ë” ë‚˜ì€ ê²½í—˜ì„ ë§Œë“¤ì–´ë³´ì„¸ìš”.
        </CardDescription>
      </CardHeader>

      <CardContent className="space-y-6">
        {/* ì•Œë¦¼ ê¶Œí•œ */}
        <div className="space-y-2">
          <Label>ì•Œë¦¼ ê¶Œí•œ</Label>
          <div className="flex items-center justify-between">
            <span className="text-sm text-muted-foreground">
              {permission === "granted"
                ? "í—ˆìš©ë¨"
                : permission === "denied"
                ? "ê±°ë¶€ë¨"
                : "ë¯¸ì„¤ì •"}
            </span>
            {!isGranted && (
              <Button onClick={handlePermissionRequest} size="sm">
                ê¶Œí•œ ìš”ì²­
              </Button>
            )}
          </div>
        </div>

        {isGranted && (
          <>
            {/* í‘¸ì‹œ ì•Œë¦¼ êµ¬ë… */}
            <div className="space-y-2">
              <Label>í‘¸ì‹œ ì•Œë¦¼</Label>
              <div className="flex items-center justify-between">
                <span className="text-sm text-muted-foreground">
                  {isSubscribed ? "êµ¬ë… ì¤‘" : "êµ¬ë… ì•ˆí•¨"}
                </span>
                <Button
                  onClick={isSubscribed ? unsubscribe : subscribe}
                  size="sm"
                  variant={isSubscribed ? "outline" : "default"}
                >
                  {isSubscribed ? "êµ¬ë… í•´ì œ" : "êµ¬ë…í•˜ê¸°"}
                </Button>
              </div>
            </div>

            {/* ì¼ì¼ ì•Œë¦¼ */}
            <div className="space-y-3">
              <div className="flex items-center justify-between">
                <Label htmlFor="daily-reminder">ì¼ì¼ ì„±ê²½ ì½ê¸° ì•Œë¦¼</Label>
                <Switch
                  id="daily-reminder"
                  checked={settings.dailyReminder}
                  onCheckedChange={(checked) =>
                    handleSettingChange("dailyReminder", checked)
                  }
                />
              </div>

              {settings.dailyReminder && (
                <div className="ml-4">
                  <Label htmlFor="reminder-time">ì•Œë¦¼ ì‹œê°„</Label>
                  <Input
                    id="reminder-time"
                    type="time"
                    value={settings.reminderTime}
                    onChange={(e) =>
                      handleSettingChange("reminderTime", e.target.value)
                    }
                    className="w-32"
                  />
                </div>
              )}
            </div>

            {/* ê¸°íƒ€ ì•Œë¦¼ ì„¤ì • */}
            <div className="space-y-3">
              <div className="flex items-center justify-between">
                <Label htmlFor="new-mission">ìƒˆ ë¯¸ì…˜ ì•Œë¦¼</Label>
                <Switch
                  id="new-mission"
                  checked={settings.newMission}
                  onCheckedChange={(checked) =>
                    handleSettingChange("newMission", checked)
                  }
                />
              </div>

              <div className="flex items-center justify-between">
                <Label htmlFor="cell-messages">ì…€ ë©”ì‹œì§€ ì•Œë¦¼</Label>
                <Switch
                  id="cell-messages"
                  checked={settings.cellMessages}
                  onCheckedChange={(checked) =>
                    handleSettingChange("cellMessages", checked)
                  }
                />
              </div>

              <div className="flex items-center justify-between">
                <Label htmlFor="post-likes">ê²Œì‹œë¬¼ ì¢‹ì•„ìš” ì•Œë¦¼</Label>
                <Switch
                  id="post-likes"
                  checked={settings.postLikes}
                  onCheckedChange={(checked) =>
                    handleSettingChange("postLikes", checked)
                  }
                />
              </div>

              <div className="flex items-center justify-between">
                <Label htmlFor="weekly-report">ì£¼ê°„ í™œë™ ìš”ì•½</Label>
                <Switch
                  id="weekly-report"
                  checked={settings.weeklyReport}
                  onCheckedChange={(checked) =>
                    handleSettingChange("weeklyReport", checked)
                  }
                />
              </div>
            </div>
          </>
        )}
      </CardContent>
    </Card>
  );
}
```

## ë°±ì—”ë“œ í‘¸ì‹œ ì•Œë¦¼ ì„œë¹„ìŠ¤

### 1. í‘¸ì‹œ ì•Œë¦¼ ì„œë¹„ìŠ¤

```typescript
// backend/src/notifications/notifications.service.ts
import * as webpush from "web-push";

@Injectable()
export class NotificationsService {
  constructor(
    @InjectRepository(PushSubscription)
    private readonly subscriptionRepository: Repository<PushSubscription>,
    private readonly configService: ConfigService
  ) {
    webpush.setVapidDetails(
      "mailto:admin@bible-daily.com",
      this.configService.get("VAPID_PUBLIC_KEY"),
      this.configService.get("VAPID_PRIVATE_KEY")
    );
  }

  async subscribe(userId: number, subscription: any): Promise<void> {
    const existingSubscription = await this.subscriptionRepository.findOne({
      where: { userId, endpoint: subscription.endpoint },
    });

    if (!existingSubscription) {
      const newSubscription = this.subscriptionRepository.create({
        userId,
        endpoint: subscription.endpoint,
        p256dh: subscription.keys.p256dh,
        auth: subscription.keys.auth,
      });

      await this.subscriptionRepository.save(newSubscription);
    }
  }

  async sendNotification(
    userId: number,
    title: string,
    body: string,
    data?: any
  ): Promise<void> {
    const subscriptions = await this.subscriptionRepository.find({
      where: { userId },
    });

    const payload = JSON.stringify({
      title,
      body,
      icon: "/icons/icon-192x192.png",
      badge: "/icons/badge-72x72.png",
      data,
    });

    const promises = subscriptions.map(async (subscription) => {
      try {
        await webpush.sendNotification(
          {
            endpoint: subscription.endpoint,
            keys: {
              p256dh: subscription.p256dh,
              auth: subscription.auth,
            },
          },
          payload
        );
      } catch (error) {
        console.error("Push notification failed:", error);

        // êµ¬ë…ì´ ìœ íš¨í•˜ì§€ ì•Šìœ¼ë©´ ì‚­ì œ
        if (error.statusCode === 410) {
          await this.subscriptionRepository.remove(subscription);
        }
      }
    });

    await Promise.all(promises);
  }

  async sendBulkNotification(
    userIds: number[],
    title: string,
    body: string,
    data?: any
  ): Promise<void> {
    const promises = userIds.map((userId) =>
      this.sendNotification(userId, title, body, data)
    );

    await Promise.all(promises);
  }
}
```

### 2. ì•Œë¦¼ íŠ¸ë¦¬ê±°

```typescript
// ìƒˆ ë¯¸ì…˜ ë“±ë¡ ì‹œ ì•Œë¦¼
@Injectable()
export class MissionsService {
  constructor(
    private readonly notificationsService: NotificationsService,
    private readonly usersService: UsersService
  ) {}

  async createMission(createMissionDto: CreateMissionDto): Promise<Mission> {
    const mission = await this.missionRepository.save(createMissionDto);

    // ëª¨ë“  í™œì„± ì‚¬ìš©ìì—ê²Œ ì•Œë¦¼ ì „ì†¡
    const activeUsers = await this.usersService.getActiveUsers();
    const userIds = activeUsers.map((user) => user.id);

    await this.notificationsService.sendBulkNotification(
      userIds,
      "ìƒˆë¡œìš´ ë¯¸ì…˜ì´ ë“±ë¡ë˜ì—ˆìŠµë‹ˆë‹¤! ğŸ“–",
      `${mission.title || "ì˜¤ëŠ˜ì˜ ë§ì”€"}ì„ í™•ì¸í•´ë³´ì„¸ìš”.`,
      { type: "new_mission", missionId: mission.id }
    );

    return mission;
  }
}

// ì¢‹ì•„ìš” ì•Œë¦¼
@Injectable()
export class PostsService {
  async toggleLike(postId: number, userId: number): Promise<void> {
    const post = await this.postRepository.findOne({
      where: { id: postId },
      relations: ["author"],
    });

    if (!post || post.author.id === userId) {
      return;
    }

    const existingLike = await this.likeRepository.findOne({
      where: { postId, userId },
    });

    if (existingLike) {
      await this.likeRepository.remove(existingLike);
    } else {
      const like = this.likeRepository.create({ postId, userId });
      await this.likeRepository.save(like);

      // ê²Œì‹œë¬¼ ì‘ì„±ìì—ê²Œ ì•Œë¦¼ ì „ì†¡
      const liker = await this.userRepository.findOne({
        where: { id: userId },
      });

      await this.notificationsService.sendNotification(
        post.author.id,
        "ìƒˆë¡œìš´ ì¢‹ì•„ìš”! â¤ï¸",
        `${liker.name}ë‹˜ì´ íšŒì›ë‹˜ì˜ ê²Œì‹œë¬¼ì„ ì¢‹ì•„í•©ë‹ˆë‹¤.`,
        { type: "post_like", postId, likerId: userId }
      );
    }
  }
}
```

## ì˜¤í”„ë¼ì¸ ì§€ì›

### 1. ìºì‹œ ì „ëµ

```javascript
// Service Workerì—ì„œ ìºì‹œ ì „ëµ êµ¬í˜„
const CACHE_STRATEGIES = {
  // ë„¤íŠ¸ì›Œí¬ ìš°ì„ , ìºì‹œ ëŒ€ì²´
  networkFirst: async (request) => {
    try {
      const response = await fetch(request);
      const cache = await caches.open(CACHE_NAME);
      cache.put(request, response.clone());
      return response;
    } catch (error) {
      const cachedResponse = await caches.match(request);
      return cachedResponse || new Response("Offline", { status: 503 });
    }
  },

  // ìºì‹œ ìš°ì„ , ë„¤íŠ¸ì›Œí¬ ëŒ€ì²´
  cacheFirst: async (request) => {
    const cachedResponse = await caches.match(request);
    if (cachedResponse) {
      return cachedResponse;
    }

    try {
      const response = await fetch(request);
      const cache = await caches.open(CACHE_NAME);
      cache.put(request, response.clone());
      return response;
    } catch (error) {
      return new Response("Offline", { status: 503 });
    }
  },
};

// ìš”ì²­ íƒ€ì…ë³„ ìºì‹œ ì „ëµ ì ìš©
self.addEventListener("fetch", (event) => {
  const { request } = event;
  const url = new URL(request.url);

  // API ìš”ì²­ì€ ë„¤íŠ¸ì›Œí¬ ìš°ì„ 
  if (url.pathname.startsWith("/api/")) {
    event.respondWith(CACHE_STRATEGIES.networkFirst(request));
  }
  // ì •ì  ë¦¬ì†ŒìŠ¤ëŠ” ìºì‹œ ìš°ì„ 
  else if (url.pathname.match(/\.(js|css|png|jpg|jpeg|gif|svg)$/)) {
    event.respondWith(CACHE_STRATEGIES.cacheFirst(request));
  }
  // ê¸°ë³¸ ì „ëµ
  else {
    event.respondWith(CACHE_STRATEGIES.networkFirst(request));
  }
});
```

### 2. ì˜¤í”„ë¼ì¸ ë°ì´í„° ë™ê¸°í™”

```typescript
// hooks/useOfflineSync.ts
export function useOfflineSync() {
  const [isOnline, setIsOnline] = useState(navigator.onLine);
  const [pendingActions, setPendingActions] = useState<any[]>([]);

  useEffect(() => {
    const handleOnline = () => setIsOnline(true);
    const handleOffline = () => setIsOnline(false);

    window.addEventListener("online", handleOnline);
    window.addEventListener("offline", handleOffline);

    return () => {
      window.removeEventListener("online", handleOnline);
      window.removeEventListener("offline", handleOffline);
    };
  }, []);

  const addPendingAction = (action: any) => {
    setPendingActions((prev) => [...prev, action]);
    localStorage.setItem(
      "pendingActions",
      JSON.stringify([...pendingActions, action])
    );
  };

  const syncPendingActions = async () => {
    if (!isOnline || pendingActions.length === 0) return;

    try {
      for (const action of pendingActions) {
        await api.request(action);
      }

      setPendingActions([]);
      localStorage.removeItem("pendingActions");
    } catch (error) {
      console.error("Sync failed:", error);
    }
  };

  useEffect(() => {
    if (isOnline) {
      syncPendingActions();
    }
  }, [isOnline]);

  return {
    isOnline,
    addPendingAction,
    syncPendingActions,
    hasPendingActions: pendingActions.length > 0,
  };
}
```
