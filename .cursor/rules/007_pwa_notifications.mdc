---
description: PWA 기능 및 푸시 알림 시스템 구현 가이드
globs:
  - "frontend/public/sw.js"
  - "frontend/src/**/*notification*"
  - "frontend/src/**/*pwa*"
alwaysApply: true
---

# PWA 및 푸시 알림 시스템

## PWA 기본 설정

### 1. Web App Manifest

```json
// frontend/public/manifest.json
{
  "name": "Bible Daily - 성경말씀 소감 공유",
  "short_name": "Bible Daily",
  "description": "중고등학생을 위한 성경말씀 소감 공유 플랫폼",
  "start_url": "/",
  "display": "standalone",
  "background_color": "#ffffff",
  "theme_color": "#f97316",
  "orientation": "portrait-primary",
  "categories": ["education", "lifestyle", "social"],
  "lang": "ko",
  "icons": [
    {
      "src": "/icons/icon-72x72.png",
      "sizes": "72x72",
      "type": "image/png",
      "purpose": "maskable any"
    },
    {
      "src": "/icons/icon-96x96.png",
      "sizes": "96x96",
      "type": "image/png",
      "purpose": "maskable any"
    },
    {
      "src": "/icons/icon-128x128.png",
      "sizes": "128x128",
      "type": "image/png",
      "purpose": "maskable any"
    },
    {
      "src": "/icons/icon-144x144.png",
      "sizes": "144x144",
      "type": "image/png",
      "purpose": "maskable any"
    },
    {
      "src": "/icons/icon-152x152.png",
      "sizes": "152x152",
      "type": "image/png",
      "purpose": "maskable any"
    },
    {
      "src": "/icons/icon-192x192.png",
      "sizes": "192x192",
      "type": "image/png",
      "purpose": "maskable any"
    },
    {
      "src": "/icons/icon-384x384.png",
      "sizes": "384x384",
      "type": "image/png",
      "purpose": "maskable any"
    },
    {
      "src": "/icons/icon-512x512.png",
      "sizes": "512x512",
      "type": "image/png",
      "purpose": "maskable any"
    }
  ],
  "shortcuts": [
    {
      "name": "오늘의 미션",
      "short_name": "미션",
      "description": "오늘의 성경 읽기 미션 확인",
      "url": "/missions/today",
      "icons": [{ "src": "/icons/shortcut-mission.png", "sizes": "96x96" }]
    },
    {
      "name": "소감 작성",
      "short_name": "소감",
      "description": "새로운 소감 작성하기",
      "url": "/posts/new",
      "icons": [{ "src": "/icons/shortcut-post.png", "sizes": "96x96" }]
    }
  ]
}
```

### 2. Service Worker 기본 구조

```javascript
// frontend/public/sw.js
const CACHE_NAME = "bible-daily-v1";
const urlsToCache = [
  "/",
  "/static/js/bundle.js",
  "/static/css/main.css",
  "/manifest.json",
  "/icons/icon-192x192.png",
  "/icons/icon-512x512.png",
];

// 설치 이벤트
self.addEventListener("install", (event) => {
  event.waitUntil(
    caches.open(CACHE_NAME).then((cache) => {
      console.log("Opened cache");
      return cache.addAll(urlsToCache);
    })
  );
});

// 활성화 이벤트
self.addEventListener("activate", (event) => {
  event.waitUntil(
    caches.keys().then((cacheNames) => {
      return Promise.all(
        cacheNames.map((cacheName) => {
          if (cacheName !== CACHE_NAME) {
            console.log("Deleting old cache:", cacheName);
            return caches.delete(cacheName);
          }
        })
      );
    })
  );
});

// 네트워크 요청 가로채기
self.addEventListener("fetch", (event) => {
  event.respondWith(
    caches.match(event.request).then((response) => {
      // 캐시에 있으면 캐시에서 반환
      if (response) {
        return response;
      }

      // 네트워크에서 가져오기
      return fetch(event.request).then((response) => {
        // 유효한 응답인지 확인
        if (!response || response.status !== 200 || response.type !== "basic") {
          return response;
        }

        // 응답 복사 (스트림은 한 번만 사용 가능)
        const responseToCache = response.clone();

        caches.open(CACHE_NAME).then((cache) => {
          cache.put(event.request, responseToCache);
        });

        return response;
      });
    })
  );
});

// 푸시 알림 수신
self.addEventListener("push", (event) => {
  console.log("Push event received:", event);

  const options = {
    body: "Bible Daily에서 새로운 알림이 있습니다.",
    icon: "/icons/icon-192x192.png",
    badge: "/icons/badge-72x72.png",
    vibrate: [100, 50, 100],
    data: {
      dateOfArrival: Date.now(),
      primaryKey: 1,
    },
    actions: [
      {
        action: "explore",
        title: "확인하기",
        icon: "/icons/checkmark.png",
      },
      {
        action: "close",
        title: "닫기",
        icon: "/icons/xmark.png",
      },
    ],
  };

  if (event.data) {
    const data = event.data.json();
    options.body = data.body || options.body;
    options.title = data.title || "Bible Daily";
    options.data = { ...options.data, ...data };
  }

  event.waitUntil(self.registration.showNotification("Bible Daily", options));
});

// 알림 클릭 처리
self.addEventListener("notificationclick", (event) => {
  console.log("Notification click received:", event);

  event.notification.close();

  if (event.action === "explore") {
    // 앱 열기 또는 포커스
    event.waitUntil(clients.openWindow("/"));
  } else if (event.action === "close") {
    // 알림만 닫기
    return;
  } else {
    // 기본 동작: 앱 열기
    event.waitUntil(clients.openWindow("/"));
  }
});

// 백그라운드 동기화
self.addEventListener("sync", (event) => {
  if (event.tag === "background-sync") {
    event.waitUntil(doBackgroundSync());
  }
});

async function doBackgroundSync() {
  // 오프라인 상태에서 저장된 데이터 동기화
  console.log("Background sync triggered");
}
```

### 3. PWA 설치 프롬프트

```typescript
// hooks/usePWAInstall.ts
export function usePWAInstall() {
  const [deferredPrompt, setDeferredPrompt] = useState<any>(null);
  const [isInstallable, setIsInstallable] = useState(false);
  const [isInstalled, setIsInstalled] = useState(false);

  useEffect(() => {
    // PWA 설치 가능 이벤트 리스너
    const handleBeforeInstallPrompt = (e: Event) => {
      e.preventDefault();
      setDeferredPrompt(e);
      setIsInstallable(true);
    };

    // PWA 설치 완료 이벤트 리스너
    const handleAppInstalled = () => {
      setIsInstalled(true);
      setIsInstallable(false);
      setDeferredPrompt(null);
    };

    window.addEventListener("beforeinstallprompt", handleBeforeInstallPrompt);
    window.addEventListener("appinstalled", handleAppInstalled);

    // 이미 설치되었는지 확인
    if (window.matchMedia("(display-mode: standalone)").matches) {
      setIsInstalled(true);
    }

    return () => {
      window.removeEventListener(
        "beforeinstallprompt",
        handleBeforeInstallPrompt
      );
      window.removeEventListener("appinstalled", handleAppInstalled);
    };
  }, []);

  const installPWA = async () => {
    if (!deferredPrompt) return false;

    deferredPrompt.prompt();
    const { outcome } = await deferredPrompt.userChoice;

    if (outcome === "accepted") {
      setDeferredPrompt(null);
      setIsInstallable(false);
      return true;
    }

    return false;
  };

  return {
    isInstallable,
    isInstalled,
    installPWA,
  };
}

// 설치 프롬프트 컴포넌트
export function PWAInstallPrompt() {
  const { isInstallable, installPWA } = usePWAInstall();
  const [showPrompt, setShowPrompt] = useState(false);

  useEffect(() => {
    if (isInstallable) {
      // 3초 후에 프롬프트 표시
      const timer = setTimeout(() => setShowPrompt(true), 3000);
      return () => clearTimeout(timer);
    }
  }, [isInstallable]);

  if (!showPrompt || !isInstallable) return null;

  return (
    <div className="fixed bottom-20 left-4 right-4 bg-primary text-primary-foreground p-4 rounded-lg shadow-lg z-50">
      <div className="flex items-center justify-between">
        <div>
          <h3 className="font-semibold">앱으로 설치하기</h3>
          <p className="text-sm opacity-90">더 빠르고 편리하게 이용하세요!</p>
        </div>
        <div className="flex gap-2">
          <Button
            variant="secondary"
            size="sm"
            onClick={() => setShowPrompt(false)}
          >
            나중에
          </Button>
          <Button
            variant="secondary"
            size="sm"
            onClick={async () => {
              const success = await installPWA();
              if (success) setShowPrompt(false);
            }}
          >
            설치
          </Button>
        </div>
      </div>
    </div>
  );
}
```

## 푸시 알림 시스템

### 1. 알림 권한 관리

```typescript
// hooks/useNotificationPermission.ts
export function useNotificationPermission() {
  const [permission, setPermission] =
    useState<NotificationPermission>("default");
  const [isSupported, setIsSupported] = useState(false);

  useEffect(() => {
    setIsSupported("Notification" in window && "serviceWorker" in navigator);

    if (isSupported) {
      setPermission(Notification.permission);
    }
  }, [isSupported]);

  const requestPermission = async (): Promise<boolean> => {
    if (!isSupported) return false;

    try {
      const result = await Notification.requestPermission();
      setPermission(result);
      return result === "granted";
    } catch (error) {
      console.error("알림 권한 요청 실패:", error);
      return false;
    }
  };

  return {
    permission,
    isSupported,
    isGranted: permission === "granted",
    isDenied: permission === "denied",
    requestPermission,
  };
}
```

### 2. 푸시 구독 관리

```typescript
// hooks/usePushSubscription.ts
export function usePushSubscription() {
  const [subscription, setSubscription] = useState<PushSubscription | null>(
    null
  );
  const [isLoading, setIsLoading] = useState(false);

  const subscribe = async (): Promise<PushSubscription | null> => {
    if (!("serviceWorker" in navigator) || !("PushManager" in window)) {
      console.error("Push messaging is not supported");
      return null;
    }

    setIsLoading(true);

    try {
      const registration = await navigator.serviceWorker.ready;

      const subscription = await registration.pushManager.subscribe({
        userVisibleOnly: true,
        applicationServerKey: urlBase64ToUint8Array(
          process.env.REACT_APP_VAPID_PUBLIC_KEY!
        ),
      });

      setSubscription(subscription);

      // 서버에 구독 정보 전송
      await api.post("/notifications/subscribe", {
        subscription: subscription.toJSON(),
      });

      return subscription;
    } catch (error) {
      console.error("Push subscription failed:", error);
      return null;
    } finally {
      setIsLoading(false);
    }
  };

  const unsubscribe = async (): Promise<boolean> => {
    if (!subscription) return false;

    setIsLoading(true);

    try {
      await subscription.unsubscribe();

      // 서버에서 구독 정보 제거
      await api.delete("/notifications/unsubscribe", {
        data: { endpoint: subscription.endpoint },
      });

      setSubscription(null);
      return true;
    } catch (error) {
      console.error("Push unsubscription failed:", error);
      return false;
    } finally {
      setIsLoading(false);
    }
  };

  useEffect(() => {
    // 기존 구독 확인
    const checkExistingSubscription = async () => {
      if ("serviceWorker" in navigator) {
        const registration = await navigator.serviceWorker.ready;
        const existingSubscription =
          await registration.pushManager.getSubscription();
        setSubscription(existingSubscription);
      }
    };

    checkExistingSubscription();
  }, []);

  return {
    subscription,
    isLoading,
    isSubscribed: !!subscription,
    subscribe,
    unsubscribe,
  };
}

// VAPID 키 변환 유틸리티
function urlBase64ToUint8Array(base64String: string): Uint8Array {
  const padding = "=".repeat((4 - (base64String.length % 4)) % 4);
  const base64 = (base64String + padding).replace(/-/g, "+").replace(/_/g, "/");

  const rawData = window.atob(base64);
  const outputArray = new Uint8Array(rawData.length);

  for (let i = 0; i < rawData.length; ++i) {
    outputArray[i] = rawData.charCodeAt(i);
  }
  return outputArray;
}
```

### 3. 로컬 알림 시스템

```typescript
// hooks/useLocalNotifications.ts
export function useLocalNotifications() {
  const { isGranted } = useNotificationPermission();

  const scheduleNotification = (
    title: string,
    options: NotificationOptions & { delay?: number } = {}
  ) => {
    if (!isGranted) return;

    const { delay = 0, ...notificationOptions } = options;

    setTimeout(() => {
      new Notification(title, {
        icon: "/icons/icon-192x192.png",
        badge: "/icons/badge-72x72.png",
        ...notificationOptions,
      });
    }, delay);
  };

  const scheduleDailyReminder = (time: string) => {
    const [hours, minutes] = time.split(":").map(Number);
    const now = new Date();
    const scheduledTime = new Date();
    scheduledTime.setHours(hours, minutes, 0, 0);

    // 오늘 시간이 지났으면 내일로 설정
    if (scheduledTime <= now) {
      scheduledTime.setDate(scheduledTime.getDate() + 1);
    }

    const delay = scheduledTime.getTime() - now.getTime();

    setTimeout(() => {
      scheduleNotification("성경 읽기 시간입니다! 📖", {
        body: "오늘의 말씀을 읽고 소감을 나누어보세요.",
        tag: "daily-reminder",
        requireInteraction: true,
      });

      // 다음 날을 위해 다시 스케줄링
      scheduleDailyReminder(time);
    }, delay);
  };

  return {
    scheduleNotification,
    scheduleDailyReminder,
  };
}
```

### 4. 알림 설정 컴포넌트

```typescript
// components/NotificationSettings.tsx
interface NotificationSettingsProps {}

export function NotificationSettings({}: NotificationSettingsProps) {
  const { permission, isGranted, requestPermission } =
    useNotificationPermission();
  const { isSubscribed, subscribe, unsubscribe } = usePushSubscription();
  const { scheduleDailyReminder } = useLocalNotifications();

  const [settings, setSettings] = useState({
    dailyReminder: true,
    reminderTime: "20:00",
    newMission: true,
    cellMessages: true,
    postLikes: true,
    weeklyReport: true,
  });

  const handlePermissionRequest = async () => {
    const granted = await requestPermission();
    if (granted && !isSubscribed) {
      await subscribe();
    }
  };

  const handleSettingChange = (
    key: keyof typeof settings,
    value: boolean | string
  ) => {
    setSettings((prev) => ({ ...prev, [key]: value }));

    // 일일 알림 시간 변경 시 스케줄 업데이트
    if (key === "reminderTime" && settings.dailyReminder) {
      scheduleDailyReminder(value as string);
    }
  };

  return (
    <Card>
      <CardHeader>
        <CardTitle>알림 설정</CardTitle>
        <CardDescription>
          원하는 알림을 설정하여 더 나은 경험을 만들어보세요.
        </CardDescription>
      </CardHeader>

      <CardContent className="space-y-6">
        {/* 알림 권한 */}
        <div className="space-y-2">
          <Label>알림 권한</Label>
          <div className="flex items-center justify-between">
            <span className="text-sm text-muted-foreground">
              {permission === "granted"
                ? "허용됨"
                : permission === "denied"
                ? "거부됨"
                : "미설정"}
            </span>
            {!isGranted && (
              <Button onClick={handlePermissionRequest} size="sm">
                권한 요청
              </Button>
            )}
          </div>
        </div>

        {isGranted && (
          <>
            {/* 푸시 알림 구독 */}
            <div className="space-y-2">
              <Label>푸시 알림</Label>
              <div className="flex items-center justify-between">
                <span className="text-sm text-muted-foreground">
                  {isSubscribed ? "구독 중" : "구독 안함"}
                </span>
                <Button
                  onClick={isSubscribed ? unsubscribe : subscribe}
                  size="sm"
                  variant={isSubscribed ? "outline" : "default"}
                >
                  {isSubscribed ? "구독 해제" : "구독하기"}
                </Button>
              </div>
            </div>

            {/* 일일 알림 */}
            <div className="space-y-3">
              <div className="flex items-center justify-between">
                <Label htmlFor="daily-reminder">일일 성경 읽기 알림</Label>
                <Switch
                  id="daily-reminder"
                  checked={settings.dailyReminder}
                  onCheckedChange={(checked) =>
                    handleSettingChange("dailyReminder", checked)
                  }
                />
              </div>

              {settings.dailyReminder && (
                <div className="ml-4">
                  <Label htmlFor="reminder-time">알림 시간</Label>
                  <Input
                    id="reminder-time"
                    type="time"
                    value={settings.reminderTime}
                    onChange={(e) =>
                      handleSettingChange("reminderTime", e.target.value)
                    }
                    className="w-32"
                  />
                </div>
              )}
            </div>

            {/* 기타 알림 설정 */}
            <div className="space-y-3">
              <div className="flex items-center justify-between">
                <Label htmlFor="new-mission">새 미션 알림</Label>
                <Switch
                  id="new-mission"
                  checked={settings.newMission}
                  onCheckedChange={(checked) =>
                    handleSettingChange("newMission", checked)
                  }
                />
              </div>

              <div className="flex items-center justify-between">
                <Label htmlFor="cell-messages">셀 메시지 알림</Label>
                <Switch
                  id="cell-messages"
                  checked={settings.cellMessages}
                  onCheckedChange={(checked) =>
                    handleSettingChange("cellMessages", checked)
                  }
                />
              </div>

              <div className="flex items-center justify-between">
                <Label htmlFor="post-likes">게시물 좋아요 알림</Label>
                <Switch
                  id="post-likes"
                  checked={settings.postLikes}
                  onCheckedChange={(checked) =>
                    handleSettingChange("postLikes", checked)
                  }
                />
              </div>

              <div className="flex items-center justify-between">
                <Label htmlFor="weekly-report">주간 활동 요약</Label>
                <Switch
                  id="weekly-report"
                  checked={settings.weeklyReport}
                  onCheckedChange={(checked) =>
                    handleSettingChange("weeklyReport", checked)
                  }
                />
              </div>
            </div>
          </>
        )}
      </CardContent>
    </Card>
  );
}
```

## 백엔드 푸시 알림 서비스

### 1. 푸시 알림 서비스

```typescript
// backend/src/notifications/notifications.service.ts
import * as webpush from "web-push";

@Injectable()
export class NotificationsService {
  constructor(
    @InjectRepository(PushSubscription)
    private readonly subscriptionRepository: Repository<PushSubscription>,
    private readonly configService: ConfigService
  ) {
    webpush.setVapidDetails(
      "mailto:admin@bible-daily.com",
      this.configService.get("VAPID_PUBLIC_KEY"),
      this.configService.get("VAPID_PRIVATE_KEY")
    );
  }

  async subscribe(userId: number, subscription: any): Promise<void> {
    const existingSubscription = await this.subscriptionRepository.findOne({
      where: { userId, endpoint: subscription.endpoint },
    });

    if (!existingSubscription) {
      const newSubscription = this.subscriptionRepository.create({
        userId,
        endpoint: subscription.endpoint,
        p256dh: subscription.keys.p256dh,
        auth: subscription.keys.auth,
      });

      await this.subscriptionRepository.save(newSubscription);
    }
  }

  async sendNotification(
    userId: number,
    title: string,
    body: string,
    data?: any
  ): Promise<void> {
    const subscriptions = await this.subscriptionRepository.find({
      where: { userId },
    });

    const payload = JSON.stringify({
      title,
      body,
      icon: "/icons/icon-192x192.png",
      badge: "/icons/badge-72x72.png",
      data,
    });

    const promises = subscriptions.map(async (subscription) => {
      try {
        await webpush.sendNotification(
          {
            endpoint: subscription.endpoint,
            keys: {
              p256dh: subscription.p256dh,
              auth: subscription.auth,
            },
          },
          payload
        );
      } catch (error) {
        console.error("Push notification failed:", error);

        // 구독이 유효하지 않으면 삭제
        if (error.statusCode === 410) {
          await this.subscriptionRepository.remove(subscription);
        }
      }
    });

    await Promise.all(promises);
  }

  async sendBulkNotification(
    userIds: number[],
    title: string,
    body: string,
    data?: any
  ): Promise<void> {
    const promises = userIds.map((userId) =>
      this.sendNotification(userId, title, body, data)
    );

    await Promise.all(promises);
  }
}
```

### 2. 알림 트리거

```typescript
// 새 미션 등록 시 알림
@Injectable()
export class MissionsService {
  constructor(
    private readonly notificationsService: NotificationsService,
    private readonly usersService: UsersService
  ) {}

  async createMission(createMissionDto: CreateMissionDto): Promise<Mission> {
    const mission = await this.missionRepository.save(createMissionDto);

    // 모든 활성 사용자에게 알림 전송
    const activeUsers = await this.usersService.getActiveUsers();
    const userIds = activeUsers.map((user) => user.id);

    await this.notificationsService.sendBulkNotification(
      userIds,
      "새로운 미션이 등록되었습니다! 📖",
      `${mission.title || "오늘의 말씀"}을 확인해보세요.`,
      { type: "new_mission", missionId: mission.id }
    );

    return mission;
  }
}

// 좋아요 알림
@Injectable()
export class PostsService {
  async toggleLike(postId: number, userId: number): Promise<void> {
    const post = await this.postRepository.findOne({
      where: { id: postId },
      relations: ["author"],
    });

    if (!post || post.author.id === userId) {
      return;
    }

    const existingLike = await this.likeRepository.findOne({
      where: { postId, userId },
    });

    if (existingLike) {
      await this.likeRepository.remove(existingLike);
    } else {
      const like = this.likeRepository.create({ postId, userId });
      await this.likeRepository.save(like);

      // 게시물 작성자에게 알림 전송
      const liker = await this.userRepository.findOne({
        where: { id: userId },
      });

      await this.notificationsService.sendNotification(
        post.author.id,
        "새로운 좋아요! ❤️",
        `${liker.name}님이 회원님의 게시물을 좋아합니다.`,
        { type: "post_like", postId, likerId: userId }
      );
    }
  }
}
```

## 오프라인 지원

### 1. 캐시 전략

```javascript
// Service Worker에서 캐시 전략 구현
const CACHE_STRATEGIES = {
  // 네트워크 우선, 캐시 대체
  networkFirst: async (request) => {
    try {
      const response = await fetch(request);
      const cache = await caches.open(CACHE_NAME);
      cache.put(request, response.clone());
      return response;
    } catch (error) {
      const cachedResponse = await caches.match(request);
      return cachedResponse || new Response("Offline", { status: 503 });
    }
  },

  // 캐시 우선, 네트워크 대체
  cacheFirst: async (request) => {
    const cachedResponse = await caches.match(request);
    if (cachedResponse) {
      return cachedResponse;
    }

    try {
      const response = await fetch(request);
      const cache = await caches.open(CACHE_NAME);
      cache.put(request, response.clone());
      return response;
    } catch (error) {
      return new Response("Offline", { status: 503 });
    }
  },
};

// 요청 타입별 캐시 전략 적용
self.addEventListener("fetch", (event) => {
  const { request } = event;
  const url = new URL(request.url);

  // API 요청은 네트워크 우선
  if (url.pathname.startsWith("/api/")) {
    event.respondWith(CACHE_STRATEGIES.networkFirst(request));
  }
  // 정적 리소스는 캐시 우선
  else if (url.pathname.match(/\.(js|css|png|jpg|jpeg|gif|svg)$/)) {
    event.respondWith(CACHE_STRATEGIES.cacheFirst(request));
  }
  // 기본 전략
  else {
    event.respondWith(CACHE_STRATEGIES.networkFirst(request));
  }
});
```

### 2. 오프라인 데이터 동기화

```typescript
// hooks/useOfflineSync.ts
export function useOfflineSync() {
  const [isOnline, setIsOnline] = useState(navigator.onLine);
  const [pendingActions, setPendingActions] = useState<any[]>([]);

  useEffect(() => {
    const handleOnline = () => setIsOnline(true);
    const handleOffline = () => setIsOnline(false);

    window.addEventListener("online", handleOnline);
    window.addEventListener("offline", handleOffline);

    return () => {
      window.removeEventListener("online", handleOnline);
      window.removeEventListener("offline", handleOffline);
    };
  }, []);

  const addPendingAction = (action: any) => {
    setPendingActions((prev) => [...prev, action]);
    localStorage.setItem(
      "pendingActions",
      JSON.stringify([...pendingActions, action])
    );
  };

  const syncPendingActions = async () => {
    if (!isOnline || pendingActions.length === 0) return;

    try {
      for (const action of pendingActions) {
        await api.request(action);
      }

      setPendingActions([]);
      localStorage.removeItem("pendingActions");
    } catch (error) {
      console.error("Sync failed:", error);
    }
  };

  useEffect(() => {
    if (isOnline) {
      syncPendingActions();
    }
  }, [isOnline]);

  return {
    isOnline,
    addPendingAction,
    syncPendingActions,
    hasPendingActions: pendingActions.length > 0,
  };
}
```
