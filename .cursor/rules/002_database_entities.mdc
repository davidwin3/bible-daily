---
description: 데이터베이스 엔티티 설계 및 관계 정의 규칙
globs:
  - "backend/src/entities/**"
  - "backend/src/**/*.entity.ts"
alwaysApply: true
---

# 데이터베이스 엔티티 설계 규칙

## 엔티티 구조

### 1. User (사용자)

```typescript
@Entity("users")
export class User {
  @PrimaryGeneratedColumn()
  id: number;

  @Column({ unique: true })
  googleId: string;

  @Column()
  email: string;

  @Column()
  name: string;

  @Column({ nullable: true })
  profileImage?: string;

  @Column({
    type: "enum",
    enum: UserRole,
    default: UserRole.STUDENT,
  })
  role: UserRole;

  @Column({ default: true })
  isActive: boolean;

  @CreateDateColumn()
  createdAt: Date;

  @UpdateDateColumn()
  updatedAt: Date;

  // Relations
  @OneToMany(() => Post, (post) => post.author)
  posts: Post[];

  @OneToMany(() => Like, (like) => like.user)
  likes: Like[];

  @OneToMany(() => UserMission, (userMission) => userMission.user)
  userMissions: UserMission[];

  @OneToOne(() => CellMember, (cellMember) => cellMember.user)
  cellMember: CellMember;
}

enum UserRole {
  STUDENT = "student",
  TEACHER = "teacher",
  ADMIN = "admin",
}
```

### 2. Post (게시물)

```typescript
@Entity("posts")
export class Post {
  @PrimaryGeneratedColumn()
  id: number;

  @Column()
  title: string;

  @Column("text")
  content: string;

  @Column({ nullable: true })
  bibleVerse?: string;

  @Column({ default: false })
  isDeleted: boolean;

  @CreateDateColumn()
  createdAt: Date;

  @UpdateDateColumn()
  updatedAt: Date;

  // Relations
  @ManyToOne(() => User, (user) => user.posts)
  @JoinColumn({ name: "authorId" })
  author: User;

  @Column()
  authorId: number;

  @OneToMany(() => Like, (like) => like.post)
  likes: Like[];

  // Computed properties
  @VirtualColumn({
    query: (alias) =>
      `SELECT COUNT(*) FROM likes WHERE likes.postId = ${alias}.id`,
  })
  likeCount: number;
}
```

### 3. Like (좋아요)

```typescript
@Entity("likes")
@Unique(["userId", "postId"])
export class Like {
  @PrimaryGeneratedColumn()
  id: number;

  @CreateDateColumn()
  createdAt: Date;

  // Relations
  @ManyToOne(() => User, (user) => user.likes)
  @JoinColumn({ name: "userId" })
  user: User;

  @Column()
  userId: number;

  @ManyToOne(() => Post, (post) => post.likes)
  @JoinColumn({ name: "postId" })
  post: Post;

  @Column()
  postId: number;
}
```

### 4. Mission (미션)

```typescript
@Entity("missions")
export class Mission {
  @PrimaryGeneratedColumn()
  id: number;

  @Column({ type: "date", unique: true })
  date: Date;

  @Column()
  startBook: string;

  @Column()
  startChapter: number;

  @Column({ nullable: true })
  startVerse?: number;

  @Column({ nullable: true })
  endBook?: string;

  @Column({ nullable: true })
  endChapter?: number;

  @Column({ nullable: true })
  endVerse?: number;

  @Column({ nullable: true })
  title?: string;

  @Column({ type: "text", nullable: true })
  description?: string;

  @CreateDateColumn()
  createdAt: Date;

  @UpdateDateColumn()
  updatedAt: Date;

  // Relations
  @OneToMany(() => UserMission, (userMission) => userMission.mission)
  userMissions: UserMission[];

  // Computed properties
  @VirtualColumn({
    query: (alias) =>
      `SELECT COUNT(*) FROM user_missions WHERE user_missions.missionId = ${alias}.id AND user_missions.isCompleted = true`,
  })
  completionCount: number;
}
```

### 5. UserMission (사용자 미션 완료 현황)

```typescript
@Entity("user_missions")
@Unique(["userId", "missionId"])
export class UserMission {
  @PrimaryGeneratedColumn()
  id: number;

  @Column({ default: false })
  isCompleted: boolean;

  @Column({ nullable: true })
  completedAt?: Date;

  @CreateDateColumn()
  createdAt: Date;

  @UpdateDateColumn()
  updatedAt: Date;

  // Relations
  @ManyToOne(() => User, (user) => user.userMissions)
  @JoinColumn({ name: "userId" })
  user: User;

  @Column()
  userId: number;

  @ManyToOne(() => Mission, (mission) => mission.userMissions)
  @JoinColumn({ name: "missionId" })
  mission: Mission;

  @Column()
  missionId: number;
}
```

### 6. Cell (셀/소그룹)

```typescript
@Entity("cells")
export class Cell {
  @PrimaryGeneratedColumn()
  id: number;

  @Column()
  name: string;

  @Column({ type: "text", nullable: true })
  description?: string;

  @Column({ default: true })
  isActive: boolean;

  @CreateDateColumn()
  createdAt: Date;

  @UpdateDateColumn()
  updatedAt: Date;

  // Relations
  @OneToMany(() => CellMember, (cellMember) => cellMember.cell)
  members: CellMember[];

  // Computed properties
  @VirtualColumn({
    query: (alias) =>
      `SELECT COUNT(*) FROM cell_members WHERE cell_members.cellId = ${alias}.id AND cell_members.isActive = true`,
  })
  memberCount: number;
}
```

### 7. CellMember (셀 구성원)

```typescript
@Entity("cell_members")
@Unique(["userId", "cellId"])
export class CellMember {
  @PrimaryGeneratedColumn()
  id: number;

  @Column({
    type: "enum",
    enum: CellRole,
    default: CellRole.MEMBER,
  })
  role: CellRole;

  @Column({ default: true })
  isActive: boolean;

  @Column({ nullable: true })
  joinedAt?: Date;

  @CreateDateColumn()
  createdAt: Date;

  @UpdateDateColumn()
  updatedAt: Date;

  // Relations
  @OneToOne(() => User, (user) => user.cellMember)
  @JoinColumn({ name: "userId" })
  user: User;

  @Column()
  userId: number;

  @ManyToOne(() => Cell, (cell) => cell.members)
  @JoinColumn({ name: "cellId" })
  cell: Cell;

  @Column()
  cellId: number;
}

enum CellRole {
  MEMBER = "member",
  LEADER = "leader",
}
```

## 데이터베이스 설계 원칙

### 1. 네이밍 컨벤션

- **테이블명**: snake_case 복수형 (예: `users`, `cell_members`)
- **컬럼명**: camelCase (예: `createdAt`, `isActive`)
- **외래키**: `{테이블명}Id` 형식 (예: `userId`, `postId`)
- **인덱스**: `idx_{테이블명}_{컬럼명}` 형식

### 2. 공통 필드

모든 엔티티는 다음 필드를 포함해야 합니다:

```typescript
@CreateDateColumn()
createdAt: Date;

@UpdateDateColumn()
updatedAt: Date;
```

### 3. 소프트 삭제

중요한 데이터는 물리적 삭제 대신 논리적 삭제를 사용:

```typescript
@Column({ default: false })
isDeleted: boolean;
```

### 4. 관계 설정 규칙

- **일대다 관계**: `@OneToMany`와 `@ManyToOne` 사용
- **다대다 관계**: 중간 테이블 생성하여 일대다로 분해
- **외래키 제약조건**: 항상 명시적으로 설정
- **Cascade 옵션**: 신중하게 사용 (주로 `['remove']`는 피함)

### 5. 인덱스 전략

```typescript
// 복합 인덱스
@Index(['userId', 'createdAt'])

// 유니크 제약조건
@Unique(['userId', 'postId'])

// 검색용 인덱스
@Index(['title'])
@Index(['createdAt'])
```

### 6. 데이터 타입 가이드라인

- **ID**: `number` (auto increment)
- **문자열**: `string` (기본 VARCHAR(255))
- **긴 텍스트**: `'text'` 타입 명시
- **날짜**: `Date` 타입 사용
- **불린**: `boolean` 타입, 기본값 설정
- **열거형**: TypeScript enum 활용

### 7. 성능 최적화

- **가상 컬럼**: 계산된 값은 `@VirtualColumn` 사용
- **지연 로딩**: 기본값으로 사용, 필요시 eager loading
- **배치 처리**: N+1 문제 방지를 위한 적절한 join 사용

### 8. 보안 고려사항

- **민감 정보**: 별도 암호화 처리
- **사용자 입력**: 항상 검증 및 이스케이프
- **권한 확인**: 엔티티 레벨에서 접근 제어 로직 구현
