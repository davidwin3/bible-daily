---
description: 인증/인가 시스템 및 보안 규칙 정의
globs:
  - "backend/src/auth/**"
  - "frontend/src/contexts/AuthContext.tsx"
  - "frontend/src/hooks/auth/**"
alwaysApply: true
---

# 인증/인가 및 보안 규칙

## 인증 시스템 구조

### 1. Google OAuth 2.0 연동

```typescript
// Backend - Google Strategy
@Injectable()
export class GoogleStrategy extends PassportStrategy(Strategy, "google") {
  constructor(
    private readonly authService: AuthService,
    private readonly configService: ConfigService
  ) {
    super({
      clientID: configService.get("GOOGLE_CLIENT_ID"),
      clientSecret: configService.get("GOOGLE_CLIENT_SECRET"),
      callbackURL: configService.get("GOOGLE_CALLBACK_URL"),
      scope: ["email", "profile"],
    });
  }

  async validate(
    accessToken: string,
    refreshToken: string,
    profile: any
  ): Promise<any> {
    const { id, name, emails, photos } = profile;

    const user = {
      googleId: id,
      email: emails[0].value,
      name: name.givenName + " " + name.familyName,
      profileImage: photos[0].value,
    };

    return this.authService.validateGoogleUser(user);
  }
}
```

### 2. JWT 토큰 관리

```typescript
// JWT Strategy
@Injectable()
export class JwtStrategy extends PassportStrategy(Strategy) {
  constructor(
    private readonly configService: ConfigService,
    @InjectRepository(User)
    private readonly userRepository: Repository<User>
  ) {
    super({
      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
      ignoreExpiration: false,
      secretOrKey: configService.get("JWT_SECRET"),
    });
  }

  async validate(payload: JwtPayload): Promise<User> {
    const { sub: userId } = payload;

    const user = await this.userRepository.findOne({
      where: { id: userId, isActive: true },
      relations: ["cellMember", "cellMember.cell"],
    });

    if (!user) {
      throw new UnauthorizedException("사용자를 찾을 수 없습니다");
    }

    return user;
  }
}

interface JwtPayload {
  sub: number;
  email: string;
  role: UserRole;
  iat: number;
  exp: number;
}
```

### 3. 토큰 생성 및 관리

```typescript
@Injectable()
export class AuthService {
  constructor(
    @InjectRepository(User)
    private readonly userRepository: Repository<User>,
    private readonly jwtService: JwtService,
    private readonly configService: ConfigService
  ) {}

  async generateTokens(user: User): Promise<AuthTokens> {
    const payload: JwtPayload = {
      sub: user.id,
      email: user.email,
      role: user.role,
      iat: Math.floor(Date.now() / 1000),
      exp: Math.floor(Date.now() / 1000) + 24 * 60 * 60, // 24시간
    };

    const accessToken = this.jwtService.sign(payload, {
      expiresIn: "24h",
    });

    const refreshToken = this.jwtService.sign(
      { sub: user.id },
      {
        secret: this.configService.get("JWT_REFRESH_SECRET"),
        expiresIn: "7d",
      }
    );

    return { accessToken, refreshToken };
  }

  async refreshAccessToken(refreshToken: string): Promise<AuthTokens> {
    try {
      const payload = this.jwtService.verify(refreshToken, {
        secret: this.configService.get("JWT_REFRESH_SECRET"),
      });

      const user = await this.userRepository.findOne({
        where: { id: payload.sub, isActive: true },
      });

      if (!user) {
        throw new UnauthorizedException("사용자를 찾을 수 없습니다");
      }

      return this.generateTokens(user);
    } catch (error) {
      throw new UnauthorizedException("유효하지 않은 리프레시 토큰입니다");
    }
  }
}

interface AuthTokens {
  accessToken: string;
  refreshToken: string;
}
```

## 권한 관리 시스템

### 1. 역할 기반 접근 제어 (RBAC)

```typescript
export enum UserRole {
  STUDENT = "student",
  TEACHER = "teacher",
  ADMIN = "admin",
}

export enum CellRole {
  MEMBER = "member",
  LEADER = "leader",
}

// 권한 체크 데코레이터
export const Roles = (...roles: UserRole[]) => SetMetadata("roles", roles);

// 권한 가드
@Injectable()
export class RolesGuard implements CanActivate {
  constructor(private reflector: Reflector) {}

  canActivate(context: ExecutionContext): boolean {
    const requiredRoles = this.reflector.getAllAndOverride<UserRole[]>(
      "roles",
      [context.getHandler(), context.getClass()]
    );

    if (!requiredRoles) {
      return true;
    }

    const { user } = context.switchToHttp().getRequest();
    return requiredRoles.some((role) => user.role === role);
  }
}
```

### 2. 특정 권한 가드

```typescript
// 교사 권한 가드
@Injectable()
export class TeacherGuard implements CanActivate {
  canActivate(context: ExecutionContext): boolean {
    const request = context.switchToHttp().getRequest();
    const user = request.user;

    return (
      user && (user.role === UserRole.TEACHER || user.role === UserRole.ADMIN)
    );
  }
}

// 관리자 권한 가드
@Injectable()
export class AdminGuard implements CanActivate {
  canActivate(context: ExecutionContext): boolean {
    const request = context.switchToHttp().getRequest();
    const user = request.user;

    return user && user.role === UserRole.ADMIN;
  }
}

// 셀 리더 권한 가드
@Injectable()
export class CellLeaderGuard implements CanActivate {
  canActivate(context: ExecutionContext): boolean {
    const request = context.switchToHttp().getRequest();
    const user = request.user;

    return (
      user &&
      user.cellMember &&
      (user.cellMember.role === CellRole.LEADER || user.role === UserRole.ADMIN)
    );
  }
}
```

### 3. 리소스 소유권 확인

```typescript
// 게시물 소유권 가드
@Injectable()
export class PostOwnerGuard implements CanActivate {
  constructor(
    @InjectRepository(Post)
    private readonly postRepository: Repository<Post>
  ) {}

  async canActivate(context: ExecutionContext): Promise<boolean> {
    const request = context.switchToHttp().getRequest();
    const user = request.user;
    const postId = parseInt(request.params.id);

    if (user.role === UserRole.ADMIN) {
      return true;
    }

    const post = await this.postRepository.findOne({
      where: { id: postId },
      relations: ["author"],
    });

    return post && post.author.id === user.id;
  }
}
```

## Frontend 인증 관리

### 1. Auth Context

```typescript
interface AuthContextType {
  user: User | null;
  isLoading: boolean;
  isAuthenticated: boolean;
  login: (tokens: AuthTokens) => void;
  logout: () => void;
  refreshToken: () => Promise<void>;
}

const AuthContext = createContext<AuthContextType | undefined>(undefined);

export function AuthProvider({ children }: { children: React.ReactNode }) {
  const [user, setUser] = useState<User | null>(null);
  const [isLoading, setIsLoading] = useState(true);

  const login = useCallback((tokens: AuthTokens) => {
    localStorage.setItem("accessToken", tokens.accessToken);
    localStorage.setItem("refreshToken", tokens.refreshToken);

    // JWT 디코딩하여 사용자 정보 추출
    const decodedToken = jwtDecode<JwtPayload>(tokens.accessToken);
    // 사용자 정보 API 호출하여 전체 정보 가져오기
    fetchUserProfile();
  }, []);

  const logout = useCallback(() => {
    localStorage.removeItem("accessToken");
    localStorage.removeItem("refreshToken");
    setUser(null);
    window.location.href = "/login";
  }, []);

  const refreshToken = useCallback(async () => {
    try {
      const refreshToken = localStorage.getItem("refreshToken");
      if (!refreshToken) {
        throw new Error("No refresh token");
      }

      const response = await api.post("/auth/refresh", { refreshToken });
      const tokens = response.data;

      login(tokens);
    } catch (error) {
      logout();
    }
  }, [login, logout]);

  // 토큰 자동 갱신
  useEffect(() => {
    const token = localStorage.getItem("accessToken");
    if (token) {
      try {
        const decodedToken = jwtDecode<JwtPayload>(token);
        const currentTime = Date.now() / 1000;

        if (decodedToken.exp < currentTime) {
          refreshToken();
        } else {
          fetchUserProfile();
        }
      } catch (error) {
        logout();
      }
    } else {
      setIsLoading(false);
    }
  }, []);

  const fetchUserProfile = async () => {
    try {
      const response = await api.get("/auth/me");
      setUser(response.data);
    } catch (error) {
      logout();
    } finally {
      setIsLoading(false);
    }
  };

  const value = {
    user,
    isLoading,
    isAuthenticated: !!user,
    login,
    logout,
    refreshToken,
  };

  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;
}

export function useAuth() {
  const context = useContext(AuthContext);
  if (context === undefined) {
    throw new Error("useAuth must be used within an AuthProvider");
  }
  return context;
}
```

### 2. API 인터셉터

```typescript
// Axios 인터셉터 설정
api.interceptors.request.use(
  (config) => {
    const token = localStorage.getItem("accessToken");
    if (token) {
      config.headers.Authorization = `Bearer ${token}`;
    }
    return config;
  },
  (error) => Promise.reject(error)
);

api.interceptors.response.use(
  (response) => response,
  async (error) => {
    const originalRequest = error.config;

    if (error.response?.status === 401 && !originalRequest._retry) {
      originalRequest._retry = true;

      try {
        const refreshToken = localStorage.getItem("refreshToken");
        if (!refreshToken) {
          throw new Error("No refresh token");
        }

        const response = await api.post("/auth/refresh", { refreshToken });
        const { accessToken } = response.data;

        localStorage.setItem("accessToken", accessToken);
        originalRequest.headers.Authorization = `Bearer ${accessToken}`;

        return api(originalRequest);
      } catch (refreshError) {
        localStorage.removeItem("accessToken");
        localStorage.removeItem("refreshToken");
        window.location.href = "/login";
        return Promise.reject(refreshError);
      }
    }

    return Promise.reject(error);
  }
);
```

### 3. 보호된 라우트

```typescript
interface ProtectedRouteProps {
  children: React.ReactNode;
  requiredRole?: UserRole;
  fallback?: React.ReactNode;
}

export function ProtectedRoute({
  children,
  requiredRole,
  fallback = <Navigate to="/login" />,
}: ProtectedRouteProps) {
  const { user, isLoading, isAuthenticated } = useAuth();

  if (isLoading) {
    return <LoadingSpinner />;
  }

  if (!isAuthenticated) {
    return fallback;
  }

  if (
    requiredRole &&
    user?.role !== requiredRole &&
    user?.role !== UserRole.ADMIN
  ) {
    return <Navigate to="/unauthorized" />;
  }

  return <>{children}</>;
}

// 사용 예시
<Routes>
  <Route path="/login" element={<LoginPage />} />
  <Route
    path="/"
    element={
      <ProtectedRoute>
        <HomePage />
      </ProtectedRoute>
    }
  />
  <Route
    path="/admin/*"
    element={
      <ProtectedRoute requiredRole={UserRole.ADMIN}>
        <AdminRoutes />
      </ProtectedRoute>
    }
  />
</Routes>;
```

## 보안 규칙

### 1. 입력 검증 및 새니타이제이션

```typescript
// DTO 검증
export class CreatePostDto {
  @IsString()
  @IsNotEmpty()
  @MaxLength(100)
  @Transform(({ value }) => value?.trim())
  title: string;

  @IsString()
  @IsNotEmpty()
  @MaxLength(1000)
  @Transform(({ value }) => sanitizeHtml(value))
  content: string;
}

// HTML 새니타이제이션
import DOMPurify from "dompurify";

export function sanitizeHtml(html: string): string {
  return DOMPurify.sanitize(html, {
    ALLOWED_TAGS: ["b", "i", "em", "strong", "br"],
    ALLOWED_ATTR: [],
  });
}
```

### 2. Rate Limiting

```typescript
// 요청 제한 설정
@Injectable()
export class RateLimitGuard implements CanActivate {
  private readonly requests = new Map<string, number[]>();

  canActivate(context: ExecutionContext): boolean {
    const request = context.switchToHttp().getRequest();
    const key = `${request.ip}-${request.user?.id || "anonymous"}`;
    const now = Date.now();
    const windowMs = 15 * 60 * 1000; // 15분
    const maxRequests = 100;

    const userRequests = this.requests.get(key) || [];
    const validRequests = userRequests.filter((time) => now - time < windowMs);

    if (validRequests.length >= maxRequests) {
      throw new HttpException(
        "Too Many Requests",
        HttpStatus.TOO_MANY_REQUESTS
      );
    }

    validRequests.push(now);
    this.requests.set(key, validRequests);

    return true;
  }
}
```

### 3. CORS 설정

```typescript
// main.ts
app.enableCors({
  origin: [
    "http://localhost:5173", // 개발 환경
    "https://bible-daily.com", // 운영 환경
  ],
  credentials: true,
  methods: ["GET", "POST", "PUT", "PATCH", "DELETE"],
  allowedHeaders: ["Content-Type", "Authorization"],
});
```

### 4. 환경 변수 보안

```typescript
// .env 파일 구조
NODE_ENV=development
PORT=3000

# 데이터베이스
DB_HOST=localhost
DB_PORT=3306
DB_USERNAME=bible_user
DB_PASSWORD=secure_password
DB_DATABASE=bible_daily

# JWT
JWT_SECRET=your-super-secret-jwt-key-here
JWT_REFRESH_SECRET=your-super-secret-refresh-key-here

# Google OAuth
GOOGLE_CLIENT_ID=your-google-client-id
GOOGLE_CLIENT_SECRET=your-google-client-secret
GOOGLE_CALLBACK_URL=http://localhost:3000/auth/google/callback

# 암호화
ENCRYPTION_KEY=your-32-character-encryption-key
```

### 5. 데이터 암호화

```typescript
// 민감한 데이터 암호화
import { createCipher, createDecipher } from "crypto";

@Injectable()
export class EncryptionService {
  private readonly algorithm = "aes-256-cbc";
  private readonly key: string;

  constructor(private readonly configService: ConfigService) {
    this.key = this.configService.get("ENCRYPTION_KEY");
  }

  encrypt(text: string): string {
    const cipher = createCipher(this.algorithm, this.key);
    let encrypted = cipher.update(text, "utf8", "hex");
    encrypted += cipher.final("hex");
    return encrypted;
  }

  decrypt(encryptedText: string): string {
    const decipher = createDecipher(this.algorithm, this.key);
    let decrypted = decipher.update(encryptedText, "hex", "utf8");
    decrypted += decipher.final("utf8");
    return decrypted;
  }
}
```

### 6. 로깅 및 모니터링

```typescript
// 보안 이벤트 로깅
@Injectable()
export class SecurityLogger {
  private readonly logger = new Logger(SecurityLogger.name);

  logLoginAttempt(email: string, success: boolean, ip: string) {
    this.logger.log(`Login attempt: ${email}, Success: ${success}, IP: ${ip}`);
  }

  logUnauthorizedAccess(userId: number, resource: string, ip: string) {
    this.logger.warn(
      `Unauthorized access: User ${userId}, Resource: ${resource}, IP: ${ip}`
    );
  }

  logSuspiciousActivity(userId: number, activity: string, ip: string) {
    this.logger.error(
      `Suspicious activity: User ${userId}, Activity: ${activity}, IP: ${ip}`
    );
  }
}
```

## 세션 관리

### 1. 토큰 만료 처리

```typescript
// 토큰 만료 시간 체크
export function useTokenExpiry() {
  const { logout, refreshToken } = useAuth();

  useEffect(() => {
    const checkTokenExpiry = () => {
      const token = localStorage.getItem("accessToken");
      if (token) {
        try {
          const decodedToken = jwtDecode<JwtPayload>(token);
          const currentTime = Date.now() / 1000;
          const timeUntilExpiry = decodedToken.exp - currentTime;

          // 토큰이 5분 이내에 만료되면 갱신
          if (timeUntilExpiry < 300) {
            refreshToken();
          }
        } catch (error) {
          logout();
        }
      }
    };

    // 1분마다 체크
    const interval = setInterval(checkTokenExpiry, 60000);
    return () => clearInterval(interval);
  }, [logout, refreshToken]);
}
```

### 2. 자동 로그아웃

```typescript
// 비활성 상태 감지
export function useIdleTimer() {
  const { logout } = useAuth();
  const timeoutRef = useRef<NodeJS.Timeout>();

  const resetTimer = useCallback(() => {
    if (timeoutRef.current) {
      clearTimeout(timeoutRef.current);
    }

    // 30분 비활성 시 자동 로그아웃
    timeoutRef.current = setTimeout(() => {
      logout();
    }, 30 * 60 * 1000);
  }, [logout]);

  useEffect(() => {
    const events = [
      "mousedown",
      "mousemove",
      "keypress",
      "scroll",
      "touchstart",
    ];

    events.forEach((event) => {
      document.addEventListener(event, resetTimer, true);
    });

    resetTimer();

    return () => {
      events.forEach((event) => {
        document.removeEventListener(event, resetTimer, true);
      });
      if (timeoutRef.current) {
        clearTimeout(timeoutRef.current);
      }
    };
  }, [resetTimer]);
}
```
