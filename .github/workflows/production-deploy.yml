name: Production Deployment to OCI

on:
  # ÏàòÎèô Ïã§Ìñâ Ìä∏Î¶¨Í±∞
  workflow_dispatch:
    inputs:
      service:
        description: "Î∞∞Ìè¨Ìï† ÏÑúÎπÑÏä§Î•º ÏÑ†ÌÉùÌïòÏÑ∏Ïöî"
        required: true
        default: "all"
        type: choice
        options:
          - all
          - backend
          - frontend
      force_deploy:
        description: "Í∞ïÏ†ú Î∞∞Ìè¨ (Î≥ÄÍ≤ΩÏÇ¨Ìï≠ Î¨¥ÏãúÌïòÍ≥† Î¨¥Ï°∞Í±¥ Î∞∞Ìè¨)"
        required: false
        default: false
        type: boolean
      force_rebuild:
        description: "Í∞ïÏ†úÎ°ú Ïù¥ÎØ∏ÏßÄÎ•º Îã§Ïãú ÎπåÎìúÌï†ÏßÄ ÏÑ†ÌÉùÌïòÏÑ∏Ïöî"
        required: false
        default: false
        type: boolean
      skip_tests:
        description: "ÌÖåÏä§Ìä∏Î•º Í±¥ÎÑàÎõ∏ÏßÄ ÏÑ†ÌÉùÌïòÏÑ∏Ïöî"
        required: false
        default: false
        type: boolean
      enable_db_sync:
        description: "Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ïä§ÌÇ§Îßà ÎèôÍ∏∞Ìôî ÌôúÏÑ±Ìôî (Ï¥àÍ∏∞ Î∞∞Ìè¨ÏãúÏóêÎßå ÏÇ¨Ïö©)"
        required: false
        default: false
        type: boolean
      migration_mode:
        description: "ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò Ïã§Ìñâ Î™®Îìú"
        required: false
        default: "none"
        type: choice
        options:
          - none
          - run_migrations
          - reset_database
      deployment_environment:
        description: "Î∞∞Ìè¨ ÌôòÍ≤Ω ÏÑ†ÌÉù"
        required: false
        default: "production"
        type: choice
        options:
          - production
          - staging
          - hotfix
      rollback_version:
        description: "Î°§Î∞±Ìï† Î≤ÑÏ†Ñ (Ïòà: v1.0.0, latest Îì±)"
        required: false
        default: ""
        type: string
      maintenance_mode:
        description: "Ï†êÍ≤Ä Î™®Îìú ÌôúÏÑ±Ìôî (Î∞∞Ìè¨ Ï§ë ÏÑúÎπÑÏä§ Ï§ëÎã®)"
        required: false
        default: false
        type: boolean

  # main Î∏åÎûúÏπòÏóê Ìë∏ÏãúÎê† Îïå ÏûêÎèô Î∞∞Ìè¨ (ÌîÑÎ°úÎçïÏÖò ÌÉúÍ∑∏Í∞Ä ÏûàÎäî Í≤ΩÏö∞)
  push:
    tags:
      - "v*.*.*"
    branches:
      - main
    paths:
      - "backend/**"
      - "frontend/**"
      - "docker-compose.prod.yml"
      - ".github/workflows/production-deploy.yml"

env:
  REGISTRY: ghcr.io
  BACKEND_IMAGE_NAME: ${{ github.repository }}/backend
  FRONTEND_IMAGE_NAME: ${{ github.repository }}/frontend
  NODE_VERSION: "20"
  PNPM_VERSION: "10"

jobs:
  # Î≥ÄÍ≤ΩÏÇ¨Ìï≠ Í∞êÏßÄ Î∞è ÌôòÍ≤Ω ÏÑ§Ï†ï
  setup:
    name: Setup and Detect Changes
    runs-on: ubuntu-latest
    outputs:
      backend_changed: ${{ steps.changes.outputs.backend }}
      frontend_changed: ${{ steps.changes.outputs.frontend }}
      deploy_backend: ${{ steps.deploy.outputs.backend }}
      deploy_frontend: ${{ steps.deploy.outputs.frontend }}
      version: ${{ steps.version.outputs.version }}
      backend_image_tag: ${{ steps.backend_meta.outputs.tags }}
      frontend_image_tag: ${{ steps.frontend_meta.outputs.tags }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Detect changes
        uses: dorny/paths-filter@v3
        id: changes
        with:
          filters: |
            backend:
              - 'backend/**'
              - 'docker-compose.prod.yml'
            frontend:
              - 'frontend/**'
              - 'docker-compose.prod.yml'

      - name: Determine deployment targets
        id: deploy
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            SERVICE="${{ github.event.inputs.service }}"
            FORCE_DEPLOY="${{ github.event.inputs.force_deploy }}"
            FORCE_REBUILD="${{ github.event.inputs.force_rebuild }}"
            
            if [ "$SERVICE" = "all" ] || [ "$SERVICE" = "backend" ]; then
              if [ "$FORCE_DEPLOY" = "true" ] || [ "$FORCE_REBUILD" = "true" ] || [ "${{ steps.changes.outputs.backend }}" = "true" ]; then
                echo "backend=true" >> $GITHUB_OUTPUT
              else
                echo "backend=false" >> $GITHUB_OUTPUT
              fi
            else
              echo "backend=false" >> $GITHUB_OUTPUT
            fi
            
            if [ "$SERVICE" = "all" ] || [ "$SERVICE" = "frontend" ]; then
              if [ "$FORCE_DEPLOY" = "true" ] || [ "$FORCE_REBUILD" = "true" ] || [ "${{ steps.changes.outputs.frontend }}" = "true" ]; then
                echo "frontend=true" >> $GITHUB_OUTPUT
              else
                echo "frontend=false" >> $GITHUB_OUTPUT
              fi
            else
              echo "frontend=false" >> $GITHUB_OUTPUT
            fi
          else
            # ÏûêÎèô Î∞∞Ìè¨Ïùò Í≤ΩÏö∞ Î≥ÄÍ≤ΩÎêú ÏÑúÎπÑÏä§Îßå Î∞∞Ìè¨
            echo "backend=${{ steps.changes.outputs.backend }}" >> $GITHUB_OUTPUT
            echo "frontend=${{ steps.changes.outputs.frontend }}" >> $GITHUB_OUTPUT
          fi

      - name: Extract version
        id: version
        run: |
          if [[ $GITHUB_REF == refs/tags/* ]]; then
            VERSION=${GITHUB_REF#refs/tags/}
          else
            VERSION=$(date +%Y%m%d)-${GITHUB_SHA::8}
          fi
          echo "version=$VERSION" >> $GITHUB_OUTPUT

      - name: Extract backend metadata
        id: backend_meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.BACKEND_IMAGE_NAME }}
          tags: |
            type=ref,event=tag
            type=raw,value=latest
            type=raw,value=prod-${{ steps.version.outputs.version }}
            type=sha,prefix=prod-

      - name: Extract frontend metadata
        id: frontend_meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.FRONTEND_IMAGE_NAME }}
          tags: |
            type=ref,event=tag
            type=raw,value=latest
            type=raw,value=prod-${{ steps.version.outputs.version }}
            type=sha,prefix=prod-

  # Backend ÌÖåÏä§Ìä∏ (Ï∂îÌõÑ ÏÇ¨Ïö© ÏòàÏ†ï)
  # backend-test:
  #   name: Backend Tests
  #   runs-on: ubuntu-latest
  #   needs: setup
  #   if: |
  #     needs.setup.outputs.deploy_backend == 'true' &&
  #     github.event.inputs.skip_tests != 'true' &&
  #     github.event.inputs.force_deploy != 'true'
  #   services:
  #     mysql:
  #       image: mysql:8.0
  #       env:
  #         MYSQL_ROOT_PASSWORD: test_password
  #         MYSQL_DATABASE: bible_daily_test
  #       ports:
  #         - 3306:3306
  #       options: >-
  #         --health-cmd="mysqladmin ping"
  #         --health-interval=10s
  #         --health-timeout=5s
  #         --health-retries=3

  #     redis:
  #       image: redis:7-alpine
  #       ports:
  #         - 6379:6379
  #       options: >-
  #         --health-cmd="redis-cli ping"
  #         --health-interval=10s
  #         --health-timeout=5s
  #         --health-retries=3

  #   steps:
  #     - name: Checkout code
  #       uses: actions/checkout@v4

  #     - name: Setup pnpm
  #       uses: pnpm/action-setup@v3
  #       with:
  #         version: ${{ env.PNPM_VERSION }}

  #     - name: Setup Node.js
  #       uses: actions/setup-node@v4
  #       with:
  #         node-version: ${{ env.NODE_VERSION }}
  #         cache: "pnpm"

  #     - name: Install dependencies
  #       run: pnpm install --frozen-lockfile

  #     - name: Run ESLint
  #       run: pnpm --filter backend lint

  #     - name: Run TypeScript check
  #       run: pnpm --filter backend build

  #     - name: Create test environment file
  #       run: |
  #         cd backend
  #         cat > .env.test << EOF
  #         NODE_ENV=test
  #         DB_HOST=localhost
  #         DB_PORT=3306
  #         DB_USERNAME=root
  #         DB_PASSWORD=test_password
  #         DB_DATABASE=bible_daily_test
  #         REDIS_HOST=localhost
  #         REDIS_PORT=6379
  #         JWT_SECRET=test_jwt_secret
  #         JWT_REFRESH_SECRET=test_refresh_secret
  #         EOF

  #     # - name: Run tests
  #     #   run: |
  #     #     pnpm --filter backend test
  #     #     pnpm --filter backend test:e2e
  #     #   env:
  #     #     NODE_ENV: test
  #     #     CI: true

  # Frontend ÌÖåÏä§Ìä∏ (Ï∂îÌõÑ ÏÇ¨Ïö© ÏòàÏ†ï)
  # frontend-test:
  #   name: Frontend Tests
  #   runs-on: ubuntu-latest
  #   needs: setup
  #   if: |
  #     needs.setup.outputs.deploy_frontend == 'true' &&
  #     github.event.inputs.skip_tests != 'true' &&
  #     github.event.inputs.force_deploy != 'true'
  #   steps:
  #     - name: Checkout code
  #       uses: actions/checkout@v4

  #     - name: Setup pnpm
  #       uses: pnpm/action-setup@v3
  #       with:
  #         version: ${{ env.PNPM_VERSION }}

  #     - name: Setup Node.js
  #       uses: actions/setup-node@v4
  #       with:
  #         node-version: ${{ env.NODE_VERSION }}
  #         cache: "pnpm"

  #     - name: Install dependencies
  #       run: pnpm install --frozen-lockfile

  #     - name: Run ESLint
  #       run: pnpm --filter frontend lint

  #     - name: Run TypeScript check
  #       run: pnpm --filter frontend build

  #     - name: Run tests
  #       run: pnpm --filter frontend test
  #       env:
  #         CI: true

  # Backend Docker Ïù¥ÎØ∏ÏßÄ ÎπåÎìú (ARM64)
  build-backend:
    name: Build Backend ARM64 Image
    runs-on: ubuntu-latest
    needs: [setup]
    if: |
      always() && 
      needs.setup.outputs.deploy_backend == 'true'
    outputs:
      image: ${{ steps.image.outputs.image }}
      digest: ${{ steps.build.outputs.digest }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3
        with:
          platforms: arm64

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          platforms: linux/arm64

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GHCR_TOKEN }}

      - name: Build and push Backend Docker image
        id: build
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./backend/Dockerfile
          push: true
          platforms: linux/arm64
          tags: ${{ needs.setup.outputs.backend_image_tag }}
          labels: |
            org.opencontainers.image.title=Bible Daily Backend (Production ARM64)
            org.opencontainers.image.description=Backend API for Bible Daily application - Production ARM64
            org.opencontainers.image.source=${{ github.server_url }}/${{ github.repository }}
            org.opencontainers.image.revision=${{ github.sha }}
            org.opencontainers.image.version=${{ needs.setup.outputs.version }}
          cache-from: type=gha,scope=backend-arm64
          cache-to: type=gha,mode=max,scope=backend-arm64
          build-args: |
            NODE_ENV=production
            BUILD_VERSION=${{ needs.setup.outputs.version }}

      - name: Output image
        id: image
        run: echo "image=${{ env.REGISTRY }}/${{ env.BACKEND_IMAGE_NAME }}@${{ steps.build.outputs.digest }}" >> $GITHUB_OUTPUT

      # - name: Run Trivy vulnerability scanner
      #   uses: aquasecurity/trivy-action@master
      #   with:
      #     image-ref: ${{ steps.image.outputs.image }}
      #     format: "sarif"
      #     output: "trivy-backend-results.sarif"

      # - name: Upload Trivy scan results
      #   uses: github/codeql-action/upload-sarif@v3
      #   if: always()
      #   with:
      #     sarif_file: "trivy-backend-results.sarif"

  # Frontend Docker Ïù¥ÎØ∏ÏßÄ ÎπåÎìú (ARM64)
  build-frontend:
    name: Build Frontend ARM64 Image
    runs-on: ubuntu-latest
    needs: [setup]
    if: |
      always() && 
      needs.setup.outputs.deploy_frontend == 'true'
    outputs:
      image: ${{ steps.image.outputs.image }}
      digest: ${{ steps.build.outputs.digest }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3
        with:
          platforms: arm64

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          platforms: linux/arm64

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GHCR_TOKEN }}

      - name: Build and push Frontend Docker image
        id: build
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./frontend/Dockerfile
          push: true
          platforms: linux/arm64
          tags: ${{ needs.setup.outputs.frontend_image_tag }}
          labels: |
            org.opencontainers.image.title=Bible Daily Frontend (Production ARM64)
            org.opencontainers.image.description=Frontend application for Bible Daily - Production ARM64
            org.opencontainers.image.source=${{ github.server_url }}/${{ github.repository }}
            org.opencontainers.image.revision=${{ github.sha }}
            org.opencontainers.image.version=${{ needs.setup.outputs.version }}
          cache-from: type=gha,scope=frontend-arm64
          cache-to: type=gha,mode=max,scope=frontend-arm64
          build-args: |
            NODE_ENV=production
            BUILD_VERSION=${{ needs.setup.outputs.version }}
            VITE_FIREBASE_API_KEY=${{ secrets.VITE_FIREBASE_API_KEY }}
            VITE_FIREBASE_AUTH_DOMAIN=${{ secrets.VITE_FIREBASE_AUTH_DOMAIN }}
            VITE_FIREBASE_PROJECT_ID=${{ secrets.VITE_FIREBASE_PROJECT_ID }}
            VITE_FIREBASE_STORAGE_BUCKET=${{ secrets.VITE_FIREBASE_STORAGE_BUCKET }}
            VITE_FIREBASE_MESSAGING_SENDER_ID=${{ secrets.VITE_FIREBASE_MESSAGING_SENDER_ID }}
            VITE_FIREBASE_APP_ID=${{ secrets.VITE_FIREBASE_APP_ID }}

      - name: Output image
        id: image
        run: echo "image=${{ env.REGISTRY }}/${{ env.FRONTEND_IMAGE_NAME }}@${{ steps.build.outputs.digest }}" >> $GITHUB_OUTPUT

      # - name: Run Trivy vulnerability scanner
      #   uses: aquasecurity/trivy-action@master
      #   with:
      #     image-ref: ${{ steps.image.outputs.image }}
      #     format: "sarif"
      #     output: "trivy-frontend-results.sarif"

      # - name: Upload Trivy scan results
      #   uses: github/codeql-action/upload-sarif@v3
      #   if: always()
      #   with:
      #     sarif_file: "trivy-frontend-results.sarif"

  # Oracle Cloud ARM64 ÏÑúÎ≤Ñ Î∞∞Ìè¨
  deploy-production:
    name: Deploy to Oracle Cloud ARM64
    runs-on: ubuntu-latest
    needs: [setup, build-backend, build-frontend]
    if: |
      always() && 
      (needs.build-backend.result == 'success' || needs.build-backend.result == 'skipped') &&
      (needs.build-frontend.result == 'success' || needs.build-frontend.result == 'skipped') &&
      (needs.setup.outputs.deploy_backend == 'true' || needs.setup.outputs.deploy_frontend == 'true')
    environment: production
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Create deployment directory on server
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.ORACLE_CLOUD_SERVER_IP }}
          username: ${{ secrets.ORACLE_CLOUD_USER }}
          key: ${{ secrets.ORACLE_CLOUD_SSH_KEY }}
          script: |
            # Create main deployment directory
            sudo mkdir -p /opt/bible-daily
            sudo chown ${{ secrets.ORACLE_CLOUD_USER }}:${{ secrets.ORACLE_CLOUD_USER }} /opt/bible-daily

            # Create required data directories for Docker volumes
            mkdir -p /opt/bible-daily/data/mysql
            mkdir -p /opt/bible-daily/data/redis
            mkdir -p /opt/bible-daily/logs
            mkdir -p /opt/bible-daily/uploads
            mkdir -p /opt/bible-daily/backups

            # Create SSL directories for Let's Encrypt
            mkdir -p /opt/bible-daily/ssl/letsencrypt
            mkdir -p /opt/bible-daily/ssl/www

            # Set proper permissions
            chmod 755 /opt/bible-daily/data/mysql
            chmod 755 /opt/bible-daily/data/redis
            chmod 755 /opt/bible-daily/logs
            chmod 755 /opt/bible-daily/uploads
            chmod 755 /opt/bible-daily/backups
            chmod 755 /opt/bible-daily/ssl/letsencrypt
            chmod 755 /opt/bible-daily/ssl/www

            # Ensure MySQL data directory has correct ownership for container
            # MySQL container runs as mysql user (uid 999)
            sudo chown -R 999:999 /opt/bible-daily/data/mysql

            # Redis runs as redis user (uid 999 in alpine)
            sudo chown -R 999:999 /opt/bible-daily/data/redis

      - name: Copy deployment files to server
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.ORACLE_CLOUD_SERVER_IP }}
          username: ${{ secrets.ORACLE_CLOUD_USER }}
          key: ${{ secrets.ORACLE_CLOUD_SSH_KEY }}
          source: "docker-compose.prod.yml,deployment/,scripts/"
          target: "/opt/bible-daily/"

      - name: Deploy services to production
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.ORACLE_CLOUD_SERVER_IP }}
          username: ${{ secrets.ORACLE_CLOUD_USER }}
          key: ${{ secrets.ORACLE_CLOUD_SSH_KEY }}
          timeout: 30m
          command_timeout: 30m
          script: |
            set -e  # Exit on any error
            cd /opt/bible-daily

            # Run fix-permissions script to ensure all directories and permissions are set correctly
            echo "üîß Running fix-permissions script..."
            if [ -f scripts/fix-permissions.sh ]; then
              chmod +x scripts/fix-permissions.sh
              ./scripts/fix-permissions.sh
            else
              echo "‚ö†Ô∏è fix-permissions.sh not found, creating directories manually..."
              mkdir -p /opt/bible-daily/data/mysql
              mkdir -p /opt/bible-daily/data/redis
              mkdir -p /opt/bible-daily/logs
              mkdir -p /opt/bible-daily/uploads
              mkdir -p /opt/bible-daily/backups
              sudo chown -R 999:999 /opt/bible-daily/data/mysql 2>/dev/null || true
              sudo chown -R 999:999 /opt/bible-daily/data/redis 2>/dev/null || true
            fi

            # Verify directories exist
            ls -la /opt/bible-daily/data/
            echo "‚úÖ Directory structure verified"

            # Create production environment file
            cat > .env.production << EOF
            # Application
            NODE_ENV=${{ github.event.inputs.deployment_environment || 'production' }}
            PORT=3000

            # Database
            DB_HOST=${{ secrets.DB_HOST }}
            DB_PORT=${{ secrets.DB_PORT }}
            DB_USERNAME=${{ secrets.DB_USERNAME }}
            DB_PASSWORD=${{ secrets.DB_PASSWORD }}
            DB_ROOT_PASSWORD=${{ secrets.DB_ROOT_PASSWORD }}
            DB_DATABASE=${{ secrets.DB_DATABASE }}
            DB_SYNCHRONIZE=${{ github.event.inputs.enable_db_sync || 'false' }}

            # Redis
            REDIS_HOST=${{ secrets.REDIS_HOST }}
            REDIS_PORT=${{ secrets.REDIS_PORT }}
            REDIS_PASSWORD=${{ secrets.REDIS_PASSWORD }}

            # JWT
            JWT_SECRET=${{ secrets.JWT_SECRET }}
            JWT_REFRESH_SECRET=${{ secrets.JWT_REFRESH_SECRET }}

            # Firebase (Backend)
            FIREBASE_PROJECT_ID=${{ secrets.FIREBASE_PROJECT_ID }}
            FIREBASE_PRIVATE_KEY_ID=${{ secrets.FIREBASE_PRIVATE_KEY_ID }}
            FIREBASE_PRIVATE_KEY=$(echo "${{ secrets.FIREBASE_PRIVATE_KEY_B64 }}" | base64 -d)
            FIREBASE_CLIENT_EMAIL=${{ secrets.FIREBASE_CLIENT_EMAIL }}
            FIREBASE_CLIENT_ID=${{ secrets.FIREBASE_CLIENT_ID }}
            FIREBASE_AUTH_URI=${{ secrets.FIREBASE_AUTH_URI }}
            FIREBASE_TOKEN_URI=${{ secrets.FIREBASE_TOKEN_URI }}

            # Firebase (Frontend)
            VITE_FIREBASE_API_KEY=${{ secrets.VITE_FIREBASE_API_KEY }}
            VITE_FIREBASE_AUTH_DOMAIN=${{ secrets.VITE_FIREBASE_AUTH_DOMAIN }}
            VITE_FIREBASE_PROJECT_ID=${{ secrets.VITE_FIREBASE_PROJECT_ID }}
            VITE_FIREBASE_STORAGE_BUCKET=${{ secrets.VITE_FIREBASE_STORAGE_BUCKET }}
            VITE_FIREBASE_MESSAGING_SENDER_ID=${{ secrets.VITE_FIREBASE_MESSAGING_SENDER_ID }}
            VITE_FIREBASE_APP_ID=${{ secrets.VITE_FIREBASE_APP_ID }}
            VITE_FIREBASE_VAPID_KEY=${{ secrets.VITE_FIREBASE_VAPID_KEY }}

            # CORS
            CORS_ORIGIN=${{ vars.CORS_ORIGIN }}
            DOMAIN=${{ vars.DOMAIN }}
            SERVICE_DOMAIN=${{ vars.SERVICE_DOMAIN }}

            # Images
            BACKEND_IMAGE=${{ needs.build-backend.outputs.image || format('{0}/{1}:latest', env.REGISTRY, env.BACKEND_IMAGE_NAME) }}
            FRONTEND_IMAGE=${{ needs.build-frontend.outputs.image || format('{0}/{1}:latest', env.REGISTRY, env.FRONTEND_IMAGE_NAME) }}

            # Registry
            REGISTRY=${{ env.REGISTRY }}
            GITHUB_TOKEN=${{ secrets.GHCR_TOKEN }}
            GITHUB_ACTOR=${{ github.actor }}

            # Version
            BUILD_VERSION=${{ needs.setup.outputs.version }}

            # SSL Configuration (Always enabled)
            CERTBOT_EMAIL=${{ secrets.CERTBOT_EMAIL }}
            ADDITIONAL_DOMAINS=${{ secrets.ADDITIONAL_DOMAINS }}
            CERTBOT_STAGING=${{ secrets.CERTBOT_STAGING }}
            EOF

            # Login to GHCR
            echo '${{ secrets.GHCR_TOKEN }}' | docker login ${{ env.REGISTRY }} -u ${{ github.actor }} --password-stdin

            # Pull latest images
            if [ '${{ needs.setup.outputs.deploy_backend }}' = 'true' ]; then
              echo 'Pulling backend image...'
              docker pull ${{ needs.build-backend.outputs.image || format('{0}/{1}:latest', env.REGISTRY, env.BACKEND_IMAGE_NAME) }}
            fi

            if [ '${{ needs.setup.outputs.deploy_frontend }}' = 'true' ]; then
              echo 'Pulling frontend image...'
              docker pull ${{ needs.build-frontend.outputs.image || format('{0}/{1}:latest', env.REGISTRY, env.FRONTEND_IMAGE_NAME) }}
            fi

            # Always use SSL configuration with Let's Encrypt
            COMPOSE_FILE="docker-compose.prod.yml"
            echo "üîí Using SSL configuration with Let's Encrypt"

            # Check and create Docker volumes if needed
            echo "üîç Checking Docker volumes..."
            # SSL volumes (always created)
            if ! docker volume ls | grep -q "bible-daily_mysql_prod_data"; then
              echo "üì¶ Creating MySQL volume..."
              docker volume create bible-daily_mysql_prod_data
            fi
            if ! docker volume ls | grep -q "bible-daily_redis_prod_data"; then
              echo "üì¶ Creating Redis volume..."
              docker volume create bible-daily_redis_prod_data
            fi
            if ! docker volume ls | grep -q "bible-daily_certbot_certs"; then
              echo "üì¶ Creating Certbot certs volume..."
              docker volume create bible-daily_certbot_certs
            fi
            if ! docker volume ls | grep -q "bible-daily_certbot_www"; then
              echo "üì¶ Creating Certbot www volume..."
              docker volume create bible-daily_certbot_www
            fi

            # Handle maintenance mode
            if [ '${{ github.event.inputs.maintenance_mode }}' = 'true' ]; then
              echo 'üöß Enabling maintenance mode...'
              # Stop services for maintenance
              docker-compose -f $COMPOSE_FILE down || true
              sleep 10
            fi

            # Handle rollback if specified
            if [ -n '${{ github.event.inputs.rollback_version }}' ] && [ '${{ github.event.inputs.rollback_version }}' != '' ]; then
              echo 'üîÑ Rolling back to version: ${{ github.event.inputs.rollback_version }}'
              # Override image tags for rollback
              export BACKEND_IMAGE="${{ env.REGISTRY }}/${{ env.BACKEND_IMAGE_NAME }}:${{ github.event.inputs.rollback_version }}"
              export FRONTEND_IMAGE="${{ env.REGISTRY }}/${{ env.FRONTEND_IMAGE_NAME }}:${{ github.event.inputs.rollback_version }}"
              
              # Pull rollback images
              docker pull $BACKEND_IMAGE || echo "Warning: Could not pull backend rollback image"
              docker pull $FRONTEND_IMAGE || echo "Warning: Could not pull frontend rollback image"
            fi

            # Deploy services
            if [ '${{ needs.setup.outputs.deploy_backend }}' = 'true' ] && [ '${{ needs.setup.outputs.deploy_frontend }}' = 'true' ]; then
              echo 'üöÄ Deploying all services...'
              docker-compose -f $COMPOSE_FILE --env-file .env.production up -d
            elif [ '${{ needs.setup.outputs.deploy_backend }}' = 'true' ]; then
              echo 'üöÄ Deploying backend service...'
              docker-compose -f $COMPOSE_FILE --env-file .env.production up -d mysql redis backend
            elif [ '${{ needs.setup.outputs.deploy_frontend }}' = 'true' ]; then
              echo 'üöÄ Deploying frontend service with SSL...'
              docker-compose -f $COMPOSE_FILE --env-file .env.production up -d frontend certbot
            fi

            # Wait for services to start
            sleep 30

            # Show running containers
            docker-compose -f $COMPOSE_FILE ps

      - name: Run database migrations (if backend deployed)
        if: needs.setup.outputs.deploy_backend == 'true'
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.ORACLE_CLOUD_SERVER_IP }}
          username: ${{ secrets.ORACLE_CLOUD_USER }}
          key: ${{ secrets.ORACLE_CLOUD_SSH_KEY }}
          timeout: 10m
          command_timeout: 10m
          script: |
            set -e  # Exit on any error
            cd /opt/bible-daily

            # Validate environment file
            if [ -f scripts/validate-env.sh ]; then
              # Use validation script if available
              chmod +x scripts/validate-env.sh
              ./scripts/validate-env.sh .env.production || echo "Environment validation completed with warnings"
            fi

            # Always use SSL configuration
            COMPOSE_FILE="docker-compose.prod.yml"
            echo "Using SSL configuration: $COMPOSE_FILE"

            # Handle migration modes
            MIGRATION_MODE="${{ github.event.inputs.migration_mode || 'none' }}"
            echo "üóÑÔ∏è Migration mode: $MIGRATION_MODE"

            if [ "$MIGRATION_MODE" = "reset_database" ]; then
              echo "‚ö†Ô∏è DANGER: Resetting database - all data will be lost!"
              echo "Stopping backend service..."
              docker-compose -f $COMPOSE_FILE stop backend || true
              
              echo "Resetting MySQL database..."
              docker-compose -f $COMPOSE_FILE exec -T mysql mysql -u root -p${{ secrets.DB_ROOT_PASSWORD }} -e "DROP DATABASE IF EXISTS ${{ secrets.DB_DATABASE }}; CREATE DATABASE ${{ secrets.DB_DATABASE }} CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;" || true
              
              echo "Restarting backend with DB_SYNCHRONIZE=true..."
              # Temporarily enable synchronize for schema recreation
              docker-compose -f $COMPOSE_FILE restart backend
              sleep 30
              
            elif [ "$MIGRATION_MODE" = "run_migrations" ]; then
              echo "üîÑ Running database migrations..."
              # Here you would run your migration commands
              # docker-compose -f $COMPOSE_FILE exec -T backend npm run migration:run
              echo "Migration commands would run here (not implemented yet)"
              
            elif [ "${{ github.event.inputs.enable_db_sync }}" = "true" ]; then
              echo "üîÑ Database synchronization is enabled via DB_SYNCHRONIZE=true"
              echo "Schema will be automatically synchronized on backend startup"
            fi

            # Wait for backend to be ready after any database operations
            if [ "$MIGRATION_MODE" != "none" ] || [ "${{ github.event.inputs.enable_db_sync }}" = "true" ]; then
              echo "‚è≥ Waiting for backend to initialize after database operations..."
              sleep 60
            fi

      - name: Health check and cleanup
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.ORACLE_CLOUD_SERVER_IP }}
          username: ${{ secrets.ORACLE_CLOUD_USER }}
          key: ${{ secrets.ORACLE_CLOUD_SSH_KEY }}
          timeout: 15m
          command_timeout: 15m
          script: |
            set -e  # Exit on any error
            cd /opt/bible-daily

            # Validate environment file
            if [ -f scripts/validate-env.sh ]; then
              # Use validation script if available
              chmod +x scripts/validate-env.sh
              ./scripts/validate-env.sh .env.production || echo "Environment validation completed with warnings"
            fi

            # Always use SSL configuration
            COMPOSE_FILE="docker-compose.prod.yml"
            echo "Using SSL configuration: $COMPOSE_FILE"

            # Wait for services to be ready
            echo "‚è≥ Waiting for services to be ready..."
            sleep 60

            # Check backend health
            if [ '${{ needs.setup.outputs.deploy_backend }}' = 'true' ]; then
              for i in {1..10}; do
                if curl -f http://localhost:3000/health; then
                  echo '‚úÖ Backend health check passed'
                  break
                fi
                echo "Backend health check attempt $i failed, retrying in 10s..."
                sleep 10
              done
            fi

            # Check frontend health
            if [ '${{ needs.setup.outputs.deploy_frontend }}' = 'true' ]; then
              for i in {1..10}; do
                # Try HTTPS first (SSL always enabled), fallback to HTTP
                if curl -f -k https://localhost:443 || curl -f http://localhost:80; then
                  echo '‚úÖ Frontend health check passed'
                  break
                fi
                echo "Frontend health check attempt $i failed, retrying in 10s..."
                sleep 10
              done
            fi

            # Show final status
            docker-compose -f $COMPOSE_FILE ps
            docker system df

            # Cleanup old images to save disk space
            echo "üßπ Cleaning up old Docker images..."
            docker image prune -f

            # Remove old images (keep last 3 versions)
            echo "üóëÔ∏è Removing old backend images..."
            docker images ${{ env.REGISTRY }}/${{ env.BACKEND_IMAGE_NAME }} --format 'table {{.Repository}}:{{.Tag}}\t{{.CreatedAt}}' | tail -n +4 | head -n -3 | awk '{print $1}' | xargs -r docker rmi || true

            echo "üóëÔ∏è Removing old frontend images..."
            docker images ${{ env.REGISTRY }}/${{ env.FRONTEND_IMAGE_NAME }} --format 'table {{.Repository}}:{{.Tag}}\t{{.CreatedAt}}' | tail -n +4 | head -n -3 | awk '{print $1}' | xargs -r docker rmi || true

            echo "‚úÖ Image cleanup completed"

            echo "‚úÖ Deployment completed successfully!"

  # Î∞∞Ìè¨ ÌõÑ ÌÜµÌï© ÌÖåÏä§Ìä∏
  post-deploy-tests:
    name: Post-deployment Integration Tests
    runs-on: ubuntu-latest
    needs: [setup, deploy-production]
    if: |
      always() && 
      needs.deploy-production.result == 'success' &&
      github.event.inputs.skip_tests != 'true' &&
      github.event.inputs.force_deploy != 'true'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup pnpm
        uses: pnpm/action-setup@v3
        with:
          version: ${{ env.PNPM_VERSION }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: "pnpm"

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Run production API tests
        run: pnpm --filter backend test:api
        env:
          API_BASE_URL: https://${{ secrets.ORACLE_CLOUD_SERVER_IP }}:3000
          CI: true
        continue-on-error: true

      - name: Upload test results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: production-test-results
          path: |
            backend/test-results/
            backend/coverage/

  # Î∞∞Ìè¨ ÏïåÎ¶º
  notify:
    name: Send Deployment Notifications
    runs-on: ubuntu-latest
    needs:
      [
        setup,
        build-backend,
        build-frontend,
        deploy-production,
        post-deploy-tests,
      ]
    if: always()
    steps:
      - name: Determine deployment status
        id: status
        run: |
          if [ "${{ needs.deploy-production.result }}" = "success" ]; then
            echo "status=success" >> $GITHUB_OUTPUT
            echo "color=good" >> $GITHUB_OUTPUT
            echo "emoji=‚úÖ" >> $GITHUB_OUTPUT
          elif [ "${{ needs.deploy-production.result }}" = "failure" ]; then
            echo "status=failure" >> $GITHUB_OUTPUT
            echo "color=danger" >> $GITHUB_OUTPUT
            echo "emoji=‚ùå" >> $GITHUB_OUTPUT
          else
            echo "status=cancelled" >> $GITHUB_OUTPUT
            echo "color=warning" >> $GITHUB_OUTPUT
            echo "emoji=‚ö†Ô∏è" >> $GITHUB_OUTPUT
          fi

      - name: Send Slack notification
        if: env.SLACK_WEBHOOK_URL != ''
        uses: 8398a7/action-slack@v3
        with:
          status: custom
          custom_payload: |
            {
              "text": "${{ steps.status.outputs.emoji }} Production Î∞∞Ìè¨ ${{ steps.status.outputs.status }}",
              "attachments": [
                {
                  "color": "${{ steps.status.outputs.color }}",
                  "fields": [
                    {
                      "title": "Environment",
                      "value": "Oracle Cloud ARM64 Production",
                      "short": true
                    },
                    {
                      "title": "Version",
                      "value": "${{ needs.setup.outputs.version }}",
                      "short": true
                    },
                    {
                      "title": "Services Deployed",
                      "value": "${{ needs.setup.outputs.deploy_backend == 'true' && 'Backend' || '' }} ${{ needs.setup.outputs.deploy_frontend == 'true' && 'Frontend' || '' }}",
                      "short": true
                    },
                    {
                      "title": "Deployment Type",
                      "value": "${{ github.event.inputs.force_deploy == 'true' && 'üö® Force Deploy' || (github.event.inputs.skip_tests == 'true' && '‚ö° Skip Tests' || '‚úÖ Normal') }}",
                      "short": true
                    },
                    {
                      "title": "Environment",
                      "value": "${{ github.event.inputs.deployment_environment || 'production' }}",
                      "short": true
                    },
                    {
                      "title": "Database Sync",
                      "value": "${{ github.event.inputs.enable_db_sync == 'true' && 'üîÑ Enabled' || '‚ùå Disabled' }}",
                      "short": true
                    },
                    {
                      "title": "Migration Mode",
                      "value": "${{ github.event.inputs.migration_mode == 'reset_database' && '‚ö†Ô∏è Reset DB' || (github.event.inputs.migration_mode == 'run_migrations' && 'üîÑ Run Migrations' || '‚ûñ None') }}",
                      "short": true
                    },
                    {
                      "title": "Maintenance Mode",
                      "value": "${{ github.event.inputs.maintenance_mode == 'true' && 'üöß Enabled' || '‚úÖ Normal' }}",
                      "short": true
                    },
                    {
                      "title": "Rollback Version",
                      "value": "${{ github.event.inputs.rollback_version != '' && github.event.inputs.rollback_version || '‚ûñ None' }}",
                      "short": true
                    },
                    {
                      "title": "SSL Configuration",
                      "value": "üîí HTTPS with Let's Encrypt (Always enabled)",
                      "short": true
                    },
                    {
                      "title": "Branch",
                      "value": "${{ github.ref_name }}",
                      "short": true
                    },
                    {
                      "title": "Backend Image",
                      "value": "${{ needs.build-backend.outputs.image || 'Not deployed' }}",
                      "short": false
                    },
                    {
                      "title": "Frontend Image", 
                      "value": "${{ needs.build-frontend.outputs.image || 'Not deployed' }}",
                      "short": false
                    },
                    {
                      "title": "Commit",
                      "value": "<https://github.com/${{ github.repository }}/commit/${{ github.sha }}|${{ github.sha }}>",
                      "short": true
                    },
                    {
                      "title": "Actor",
                      "value": "${{ github.actor }}",
                      "short": true
                    }
                  ]
                }
              ]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

      - name: Create deployment summary
        run: |
          echo "## üöÄ Production Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Status:** ${{ steps.status.outputs.emoji }} ${{ steps.status.outputs.status }}" >> $GITHUB_STEP_SUMMARY
          echo "**Environment:** Oracle Cloud ARM64 ${{ github.event.inputs.deployment_environment || 'Production' }}" >> $GITHUB_STEP_SUMMARY
          echo "**Version:** ${{ needs.setup.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "**Branch:** ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
          echo "**Commit:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          if [ "${{ github.event.inputs.force_deploy }}" = "true" ]; then
            echo "**Deployment Type:** üö® **Force Deploy** (Î≥ÄÍ≤ΩÏÇ¨Ìï≠ Î¨¥Ïãú)" >> $GITHUB_STEP_SUMMARY
          elif [ "${{ github.event.inputs.skip_tests }}" = "true" ]; then
            echo "**Deployment Type:** ‚ö° **Skip Tests** (ÌÖåÏä§Ìä∏ Í±¥ÎÑàÎúÄ)" >> $GITHUB_STEP_SUMMARY
          else
            echo "**Deployment Type:** ‚úÖ **Normal** (Ï†ïÏÉÅ Î∞∞Ìè¨)" >> $GITHUB_STEP_SUMMARY
          fi
          echo "**SSL Configuration:** üîí **HTTPS with Let's Encrypt** (Always enabled)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Deployment Options" >> $GITHUB_STEP_SUMMARY
          echo "- **Database Sync:** ${{ github.event.inputs.enable_db_sync == 'true' && 'üîÑ Enabled' || '‚ùå Disabled' }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Migration Mode:** ${{ github.event.inputs.migration_mode == 'reset_database' && '‚ö†Ô∏è Reset Database' || (github.event.inputs.migration_mode == 'run_migrations' && 'üîÑ Run Migrations' || '‚ûñ None') }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Maintenance Mode:** ${{ github.event.inputs.maintenance_mode == 'true' && 'üöß Enabled' || '‚úÖ Normal Operation' }}" >> $GITHUB_STEP_SUMMARY
          if [ -n "${{ github.event.inputs.rollback_version }}" ] && [ "${{ github.event.inputs.rollback_version }}" != "" ]; then
            echo "- **Rollback Version:** üîÑ ${{ github.event.inputs.rollback_version }}" >> $GITHUB_STEP_SUMMARY
          fi
          echo "- **Image Cleanup:** üßπ Always Enabled" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Services Deployed" >> $GITHUB_STEP_SUMMARY
          if [ "${{ needs.setup.outputs.deploy_backend }}" = "true" ]; then
            echo "- ‚úÖ **Backend:** ${{ needs.build-backend.outputs.image }}" >> $GITHUB_STEP_SUMMARY
          else
            echo "- ‚è≠Ô∏è **Backend:** Not deployed" >> $GITHUB_STEP_SUMMARY
          fi
          if [ "${{ needs.setup.outputs.deploy_frontend }}" = "true" ]; then
            echo "- ‚úÖ **Frontend:** ${{ needs.build-frontend.outputs.image }}" >> $GITHUB_STEP_SUMMARY
          else
            echo "- ‚è≠Ô∏è **Frontend:** Not deployed" >> $GITHUB_STEP_SUMMARY
          fi
