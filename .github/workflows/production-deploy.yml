name: Production Deployment to OCI

on:
  # ÏàòÎèô Ïã§Ìñâ Ìä∏Î¶¨Í±∞
  workflow_dispatch:
    inputs:
      service:
        description: "Î∞∞Ìè¨Ìï† ÏÑúÎπÑÏä§Î•º ÏÑ†ÌÉùÌïòÏÑ∏Ïöî"
        required: true
        default: "all"
        type: choice
        options:
          - all
          - backend
          - frontend
      force_deploy:
        description: "Í∞ïÏ†ú Î∞∞Ìè¨ (Î≥ÄÍ≤ΩÏÇ¨Ìï≠ Î¨¥ÏãúÌïòÍ≥† Î¨¥Ï°∞Í±¥ Î∞∞Ìè¨)"
        required: false
        default: false
        type: boolean
      force_rebuild:
        description: "Í∞ïÏ†úÎ°ú Ïù¥ÎØ∏ÏßÄÎ•º Îã§Ïãú ÎπåÎìúÌï†ÏßÄ ÏÑ†ÌÉùÌïòÏÑ∏Ïöî"
        required: false
        default: false
        type: boolean
      skip_tests:
        description: "ÌÖåÏä§Ìä∏Î•º Í±¥ÎÑàÎõ∏ÏßÄ ÏÑ†ÌÉùÌïòÏÑ∏Ïöî"
        required: false
        default: false
        type: boolean
      use_ssl:
        description: "SSL Ïù∏Ï¶ùÏÑúÎ•º ÏÇ¨Ïö©Ìïú HTTPS Î∞∞Ìè¨"
        required: false
        default: false
        type: boolean

  # main Î∏åÎûúÏπòÏóê Ìë∏ÏãúÎê† Îïå ÏûêÎèô Î∞∞Ìè¨ (ÌîÑÎ°úÎçïÏÖò ÌÉúÍ∑∏Í∞Ä ÏûàÎäî Í≤ΩÏö∞)
  push:
    tags:
      - "v*.*.*"
    branches:
      - main
    paths:
      - "backend/**"
      - "frontend/**"
      - "docker-compose.prod.yml"
      - "docker-compose.ssl.yml"
      - ".github/workflows/production-deploy.yml"

env:
  REGISTRY: ghcr.io
  BACKEND_IMAGE_NAME: ${{ github.repository }}/backend
  FRONTEND_IMAGE_NAME: ${{ github.repository }}/frontend
  NODE_VERSION: "20"
  PNPM_VERSION: "10"

jobs:
  # Î≥ÄÍ≤ΩÏÇ¨Ìï≠ Í∞êÏßÄ Î∞è ÌôòÍ≤Ω ÏÑ§Ï†ï
  setup:
    name: Setup and Detect Changes
    runs-on: ubuntu-latest
    outputs:
      backend_changed: ${{ steps.changes.outputs.backend }}
      frontend_changed: ${{ steps.changes.outputs.frontend }}
      deploy_backend: ${{ steps.deploy.outputs.backend }}
      deploy_frontend: ${{ steps.deploy.outputs.frontend }}
      version: ${{ steps.version.outputs.version }}
      backend_image_tag: ${{ steps.backend_meta.outputs.tags }}
      frontend_image_tag: ${{ steps.frontend_meta.outputs.tags }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Detect changes
        uses: dorny/paths-filter@v3
        id: changes
        with:
          filters: |
            backend:
              - 'backend/**'
              - 'docker-compose.prod.yml'
            frontend:
              - 'frontend/**'
              - 'docker-compose.prod.yml'
              - 'docker-compose.ssl.yml'

      - name: Determine deployment targets
        id: deploy
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            SERVICE="${{ github.event.inputs.service }}"
            FORCE_DEPLOY="${{ github.event.inputs.force_deploy }}"
            FORCE_REBUILD="${{ github.event.inputs.force_rebuild }}"
            
            if [ "$SERVICE" = "all" ] || [ "$SERVICE" = "backend" ]; then
              if [ "$FORCE_DEPLOY" = "true" ] || [ "$FORCE_REBUILD" = "true" ] || [ "${{ steps.changes.outputs.backend }}" = "true" ]; then
                echo "backend=true" >> $GITHUB_OUTPUT
              else
                echo "backend=false" >> $GITHUB_OUTPUT
              fi
            else
              echo "backend=false" >> $GITHUB_OUTPUT
            fi
            
            if [ "$SERVICE" = "all" ] || [ "$SERVICE" = "frontend" ]; then
              if [ "$FORCE_DEPLOY" = "true" ] || [ "$FORCE_REBUILD" = "true" ] || [ "${{ steps.changes.outputs.frontend }}" = "true" ]; then
                echo "frontend=true" >> $GITHUB_OUTPUT
              else
                echo "frontend=false" >> $GITHUB_OUTPUT
              fi
            else
              echo "frontend=false" >> $GITHUB_OUTPUT
            fi
          else
            # ÏûêÎèô Î∞∞Ìè¨Ïùò Í≤ΩÏö∞ Î≥ÄÍ≤ΩÎêú ÏÑúÎπÑÏä§Îßå Î∞∞Ìè¨
            echo "backend=${{ steps.changes.outputs.backend }}" >> $GITHUB_OUTPUT
            echo "frontend=${{ steps.changes.outputs.frontend }}" >> $GITHUB_OUTPUT
          fi

      - name: Extract version
        id: version
        run: |
          if [[ $GITHUB_REF == refs/tags/* ]]; then
            VERSION=${GITHUB_REF#refs/tags/}
          else
            VERSION=$(date +%Y%m%d)-${GITHUB_SHA::8}
          fi
          echo "version=$VERSION" >> $GITHUB_OUTPUT

      - name: Extract backend metadata
        id: backend_meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.BACKEND_IMAGE_NAME }}
          tags: |
            type=ref,event=tag
            type=raw,value=latest
            type=raw,value=prod-${{ steps.version.outputs.version }}
            type=sha,prefix=prod-

      - name: Extract frontend metadata
        id: frontend_meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.FRONTEND_IMAGE_NAME }}
          tags: |
            type=ref,event=tag
            type=raw,value=latest
            type=raw,value=prod-${{ steps.version.outputs.version }}
            type=sha,prefix=prod-

  # Backend ÌÖåÏä§Ìä∏
  backend-test:
    name: Backend Tests
    runs-on: ubuntu-latest
    needs: setup
    if: |
      needs.setup.outputs.deploy_backend == 'true' && 
      github.event.inputs.skip_tests != 'true' &&
      github.event.inputs.force_deploy != 'true'
    services:
      mysql:
        image: mysql:8.0
        env:
          MYSQL_ROOT_PASSWORD: test_password
          MYSQL_DATABASE: bible_daily_test
        ports:
          - 3306:3306
        options: >-
          --health-cmd="mysqladmin ping"
          --health-interval=10s
          --health-timeout=5s
          --health-retries=3

      redis:
        image: redis:7-alpine
        ports:
          - 6379:6379
        options: >-
          --health-cmd="redis-cli ping"
          --health-interval=10s
          --health-timeout=5s
          --health-retries=3

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup pnpm
        uses: pnpm/action-setup@v3
        with:
          version: ${{ env.PNPM_VERSION }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: "pnpm"

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Run ESLint
        run: pnpm --filter backend lint

      - name: Run TypeScript check
        run: pnpm --filter backend build

      - name: Create test environment file
        run: |
          cd backend
          cat > .env.test << EOF
          NODE_ENV=test
          DB_HOST=localhost
          DB_PORT=3306
          DB_USERNAME=root
          DB_PASSWORD=test_password
          DB_DATABASE=bible_daily_test
          REDIS_HOST=localhost
          REDIS_PORT=6379
          JWT_SECRET=test_jwt_secret
          JWT_REFRESH_SECRET=test_refresh_secret
          EOF

      # - name: Run tests
      #   run: |
      #     pnpm --filter backend test
      #     pnpm --filter backend test:e2e
      #   env:
      #     NODE_ENV: test
      #     CI: true

  # Frontend ÌÖåÏä§Ìä∏
  frontend-test:
    name: Frontend Tests
    runs-on: ubuntu-latest
    needs: setup
    if: |
      needs.setup.outputs.deploy_frontend == 'true' && 
      github.event.inputs.skip_tests != 'true' &&
      github.event.inputs.force_deploy != 'true'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup pnpm
        uses: pnpm/action-setup@v3
        with:
          version: ${{ env.PNPM_VERSION }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: "pnpm"

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Run ESLint
        run: pnpm --filter frontend lint

      - name: Run TypeScript check
        run: pnpm --filter frontend build

      - name: Run tests
        run: pnpm --filter frontend test
        env:
          CI: true

  # Backend Docker Ïù¥ÎØ∏ÏßÄ ÎπåÎìú (ARM64)
  build-backend:
    name: Build Backend ARM64 Image
    runs-on: ubuntu-latest
    needs: [setup, backend-test]
    if: |
      always() && 
      needs.setup.outputs.deploy_backend == 'true' &&
      (needs.backend-test.result == 'success' || needs.backend-test.result == 'skipped')
    outputs:
      image: ${{ steps.image.outputs.image }}
      digest: ${{ steps.build.outputs.digest }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3
        with:
          platforms: arm64

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          platforms: linux/arm64

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GHCR_TOKEN }}

      - name: Build and push Backend Docker image
        id: build
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./backend/Dockerfile
          push: true
          platforms: linux/arm64
          tags: ${{ needs.setup.outputs.backend_image_tag }}
          labels: |
            org.opencontainers.image.title=Bible Daily Backend (Production ARM64)
            org.opencontainers.image.description=Backend API for Bible Daily application - Production ARM64
            org.opencontainers.image.source=${{ github.server_url }}/${{ github.repository }}
            org.opencontainers.image.revision=${{ github.sha }}
            org.opencontainers.image.version=${{ needs.setup.outputs.version }}
          cache-from: type=gha,scope=backend-arm64
          cache-to: type=gha,mode=max,scope=backend-arm64
          build-args: |
            NODE_ENV=production
            BUILD_VERSION=${{ needs.setup.outputs.version }}

      - name: Output image
        id: image
        run: echo "image=${{ env.REGISTRY }}/${{ env.BACKEND_IMAGE_NAME }}@${{ steps.build.outputs.digest }}" >> $GITHUB_OUTPUT

      # - name: Run Trivy vulnerability scanner
      #   uses: aquasecurity/trivy-action@master
      #   with:
      #     image-ref: ${{ steps.image.outputs.image }}
      #     format: "sarif"
      #     output: "trivy-backend-results.sarif"

      # - name: Upload Trivy scan results
      #   uses: github/codeql-action/upload-sarif@v3
      #   if: always()
      #   with:
      #     sarif_file: "trivy-backend-results.sarif"

  # Frontend Docker Ïù¥ÎØ∏ÏßÄ ÎπåÎìú (ARM64)
  build-frontend:
    name: Build Frontend ARM64 Image
    runs-on: ubuntu-latest
    needs: [setup, frontend-test]
    if: |
      always() && 
      needs.setup.outputs.deploy_frontend == 'true' &&
      (needs.frontend-test.result == 'success' || needs.frontend-test.result == 'skipped')
    outputs:
      image: ${{ steps.image.outputs.image }}
      digest: ${{ steps.build.outputs.digest }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3
        with:
          platforms: arm64

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          platforms: linux/arm64

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GHCR_TOKEN }}

      - name: Build and push Frontend Docker image
        id: build
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./frontend/Dockerfile
          push: true
          platforms: linux/arm64
          tags: ${{ needs.setup.outputs.frontend_image_tag }}
          labels: |
            org.opencontainers.image.title=Bible Daily Frontend (Production ARM64)
            org.opencontainers.image.description=Frontend application for Bible Daily - Production ARM64
            org.opencontainers.image.source=${{ github.server_url }}/${{ github.repository }}
            org.opencontainers.image.revision=${{ github.sha }}
            org.opencontainers.image.version=${{ needs.setup.outputs.version }}
          cache-from: type=gha,scope=frontend-arm64
          cache-to: type=gha,mode=max,scope=frontend-arm64
          build-args: |
            NODE_ENV=production
            BUILD_VERSION=${{ needs.setup.outputs.version }}

      - name: Output image
        id: image
        run: echo "image=${{ env.REGISTRY }}/${{ env.FRONTEND_IMAGE_NAME }}@${{ steps.build.outputs.digest }}" >> $GITHUB_OUTPUT

      # - name: Run Trivy vulnerability scanner
      #   uses: aquasecurity/trivy-action@master
      #   with:
      #     image-ref: ${{ steps.image.outputs.image }}
      #     format: "sarif"
      #     output: "trivy-frontend-results.sarif"

      # - name: Upload Trivy scan results
      #   uses: github/codeql-action/upload-sarif@v3
      #   if: always()
      #   with:
      #     sarif_file: "trivy-frontend-results.sarif"

  # Oracle Cloud ARM64 ÏÑúÎ≤Ñ Î∞∞Ìè¨
  deploy-production:
    name: Deploy to Oracle Cloud ARM64
    runs-on: ubuntu-latest
    needs: [setup, build-backend, build-frontend]
    if: |
      always() && 
      (needs.build-backend.result == 'success' || needs.build-backend.result == 'skipped') &&
      (needs.build-frontend.result == 'success' || needs.build-frontend.result == 'skipped') &&
      (needs.setup.outputs.deploy_backend == 'true' || needs.setup.outputs.deploy_frontend == 'true')
    environment: production
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Create deployment directory on server
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.ORACLE_CLOUD_SERVER_IP }}
          username: ${{ secrets.ORACLE_CLOUD_USER }}
          key: ${{ secrets.ORACLE_CLOUD_SSH_KEY }}
          script: |
            # Create main deployment directory
            sudo mkdir -p /opt/bible-daily
            sudo chown ${{ secrets.ORACLE_CLOUD_USER }}:${{ secrets.ORACLE_CLOUD_USER }} /opt/bible-daily

            # Create required data directories for Docker volumes
            mkdir -p /opt/bible-daily/data/mysql
            mkdir -p /opt/bible-daily/data/redis
            mkdir -p /opt/bible-daily/logs
            mkdir -p /opt/bible-daily/uploads
            mkdir -p /opt/bible-daily/backups

            # Create SSL directories for Let's Encrypt
            mkdir -p /opt/bible-daily/ssl/letsencrypt
            mkdir -p /opt/bible-daily/ssl/www

            # Set proper permissions
            chmod 755 /opt/bible-daily/data/mysql
            chmod 755 /opt/bible-daily/data/redis
            chmod 755 /opt/bible-daily/logs
            chmod 755 /opt/bible-daily/uploads
            chmod 755 /opt/bible-daily/backups
            chmod 755 /opt/bible-daily/ssl/letsencrypt
            chmod 755 /opt/bible-daily/ssl/www

            # Ensure MySQL data directory has correct ownership for container
            # MySQL container runs as mysql user (uid 999)
            sudo chown -R 999:999 /opt/bible-daily/data/mysql

            # Redis runs as redis user (uid 999 in alpine)
            sudo chown -R 999:999 /opt/bible-daily/data/redis

      - name: Copy deployment files to server
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.ORACLE_CLOUD_SERVER_IP }}
          username: ${{ secrets.ORACLE_CLOUD_USER }}
          key: ${{ secrets.ORACLE_CLOUD_SSH_KEY }}
          source: "docker-compose.prod.yml,docker-compose.ssl.yml,deployment/"
          target: "/opt/bible-daily/"

      - name: Deploy services to production
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.ORACLE_CLOUD_SERVER_IP }}
          username: ${{ secrets.ORACLE_CLOUD_USER }}
          key: ${{ secrets.ORACLE_CLOUD_SSH_KEY }}
          timeout: 30m
          command_timeout: 30m
          script: |
            set -e  # Exit on any error
            cd /opt/bible-daily

            # Ensure all required directories exist with proper permissions
            echo "üîß Ensuring all required directories exist..."
            mkdir -p /opt/bible-daily/data/mysql
            mkdir -p /opt/bible-daily/data/redis
            mkdir -p /opt/bible-daily/logs
            mkdir -p /opt/bible-daily/uploads
            mkdir -p /opt/bible-daily/backups

            # Set proper ownership for container users
            sudo chown -R 999:999 /opt/bible-daily/data/mysql 2>/dev/null || true
            sudo chown -R 999:999 /opt/bible-daily/data/redis 2>/dev/null || true

            # Verify directories exist
            ls -la /opt/bible-daily/data/
            echo "‚úÖ Directory structure verified"

            # Create production environment file
            cat > .env.production << EOF
            # Application
            NODE_ENV=production
            PORT=3000

            # Database
            DB_HOST=${{ secrets.DB_HOST }}
            DB_PORT=${{ secrets.DB_PORT }}
            DB_USERNAME=${{ secrets.DB_USERNAME }}
            DB_PASSWORD=${{ secrets.DB_PASSWORD }}
            DB_ROOT_PASSWORD=${{ secrets.DB_ROOT_PASSWORD }}
            DB_DATABASE=${{ secrets.DB_DATABASE }}

            # Redis
            REDIS_HOST=${{ secrets.REDIS_HOST }}
            REDIS_PORT=${{ secrets.REDIS_PORT }}
            REDIS_PASSWORD=${{ secrets.REDIS_PASSWORD }}

            # JWT
            JWT_SECRET=${{ secrets.JWT_SECRET }}
            JWT_REFRESH_SECRET=${{ secrets.JWT_REFRESH_SECRET }}

            # Firebase
            FIREBASE_PROJECT_ID=${{ secrets.FIREBASE_PROJECT_ID }}
            FIREBASE_PRIVATE_KEY_ID=${{ secrets.FIREBASE_PRIVATE_KEY_ID }}
            FIREBASE_PRIVATE_KEY=$(echo "${{ secrets.FIREBASE_PRIVATE_KEY_B64 }}" | base64 -d)
            FIREBASE_CLIENT_EMAIL=${{ secrets.FIREBASE_CLIENT_EMAIL }}
            FIREBASE_CLIENT_ID=${{ secrets.FIREBASE_CLIENT_ID }}
            FIREBASE_AUTH_URI=${{ secrets.FIREBASE_AUTH_URI }}
            FIREBASE_TOKEN_URI=${{ secrets.FIREBASE_TOKEN_URI }}

            # CORS
            CORS_ORIGIN=${{ vars.CORS_ORIGIN }}
            DOMAIN=${{ vars.DOMAIN }}

            # Images
            BACKEND_IMAGE=${{ needs.build-backend.outputs.image || format('{0}/{1}:latest', env.REGISTRY, env.BACKEND_IMAGE_NAME) }}
            FRONTEND_IMAGE=${{ needs.build-frontend.outputs.image || format('{0}/{1}:latest', env.REGISTRY, env.FRONTEND_IMAGE_NAME) }}

            # Registry
            REGISTRY=${{ env.REGISTRY }}
            GITHUB_TOKEN=${{ secrets.GHCR_TOKEN }}
            GITHUB_ACTOR=${{ github.actor }}

            # Version
            BUILD_VERSION=${{ needs.setup.outputs.version }}

            # SSL Configuration
            USE_SSL=${{ github.event.inputs.use_ssl }}
            CERTBOT_EMAIL=${{ secrets.CERTBOT_EMAIL }}
            ADDITIONAL_DOMAINS=${{ secrets.ADDITIONAL_DOMAINS }}
            CERTBOT_STAGING=${{ secrets.CERTBOT_STAGING }}
            EOF

            # Login to GHCR
            echo '${{ secrets.GHCR_TOKEN }}' | docker login ${{ env.REGISTRY }} -u ${{ github.actor }} --password-stdin

            # Pull latest images
            if [ '${{ needs.setup.outputs.deploy_backend }}' = 'true' ]; then
              echo 'Pulling backend image...'
              docker pull ${{ needs.build-backend.outputs.image || format('{0}/{1}:latest', env.REGISTRY, env.BACKEND_IMAGE_NAME) }}
            fi

            if [ '${{ needs.setup.outputs.deploy_frontend }}' = 'true' ]; then
              echo 'Pulling frontend image...'
              docker pull ${{ needs.build-frontend.outputs.image || format('{0}/{1}:latest', env.REGISTRY, env.FRONTEND_IMAGE_NAME) }}
            fi

            # Determine which docker-compose file to use
            COMPOSE_FILE="docker-compose.prod.yml"
            if [ "$USE_SSL" = "true" ]; then
              COMPOSE_FILE="docker-compose.ssl.yml"
              echo "üîí Using SSL configuration with Let's Encrypt"
            else
              echo "üåê Using standard HTTP configuration"
            fi

            # Check and create Docker volumes if needed
            echo "üîç Checking Docker volumes..."
            if [ "$USE_SSL" = "true" ]; then
              # SSL volumes
              if ! docker volume ls | grep -q "bible-daily_mysql_ssl_data"; then
                echo "üì¶ Creating MySQL SSL volume..."
                docker volume create bible-daily_mysql_ssl_data
              fi
              if ! docker volume ls | grep -q "bible-daily_redis_ssl_data"; then
                echo "üì¶ Creating Redis SSL volume..."
                docker volume create bible-daily_redis_ssl_data
              fi
              if ! docker volume ls | grep -q "bible-daily_certbot_certs"; then
                echo "üì¶ Creating Certbot certs volume..."
                docker volume create bible-daily_certbot_certs
              fi
              if ! docker volume ls | grep -q "bible-daily_certbot_www"; then
                echo "üì¶ Creating Certbot www volume..."
                docker volume create bible-daily_certbot_www
              fi
            else
              # Standard volumes
              if ! docker volume ls | grep -q "bible-daily_mysql_prod_data"; then
                echo "üì¶ Creating MySQL volume..."
                docker volume create bible-daily_mysql_prod_data
              fi
              if ! docker volume ls | grep -q "bible-daily_redis_prod_data"; then
                echo "üì¶ Creating Redis volume..."
                docker volume create bible-daily_redis_prod_data
              fi
            fi

            # Deploy services
            if [ '${{ needs.setup.outputs.deploy_backend }}' = 'true' ] && [ '${{ needs.setup.outputs.deploy_frontend }}' = 'true' ]; then
              echo 'üöÄ Deploying all services...'
              docker-compose -f $COMPOSE_FILE --env-file .env.production up -d
            elif [ '${{ needs.setup.outputs.deploy_backend }}' = 'true' ]; then
              echo 'üöÄ Deploying backend service...'
              docker-compose -f $COMPOSE_FILE --env-file .env.production up -d mysql redis backend
            elif [ '${{ needs.setup.outputs.deploy_frontend }}' = 'true' ]; then
              echo 'üöÄ Deploying frontend service...'
              if [ "$USE_SSL" = "true" ]; then
                docker-compose -f $COMPOSE_FILE --env-file .env.production up -d frontend certbot
              else
                docker-compose -f $COMPOSE_FILE --env-file .env.production up -d frontend
              fi
            fi

            # Wait for services to start
            sleep 30

            # Show running containers
            docker-compose -f $COMPOSE_FILE ps

      - name: Run database migrations (if backend deployed)
        if: needs.setup.outputs.deploy_backend == 'true'
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.ORACLE_CLOUD_SERVER_IP }}
          username: ${{ secrets.ORACLE_CLOUD_USER }}
          key: ${{ secrets.ORACLE_CLOUD_SSH_KEY }}
          timeout: 10m
          command_timeout: 10m
          script: |
            set -e  # Exit on any error
            cd /opt/bible-daily

            # Validate environment file and determine compose file
            if [ -f scripts/validate-env.sh ]; then
              # Use validation script if available
              chmod +x scripts/validate-env.sh
              ./scripts/validate-env.sh .env.production || echo "Environment validation completed with warnings"
              
              # Check SSL configuration using the script
              SSL_CONFIG=$(./scripts/validate-env.sh --check-ssl .env.production)
              if [ "$SSL_CONFIG" = "ssl" ]; then
                COMPOSE_FILE="docker-compose.ssl.yml"
                echo "Using SSL configuration: $COMPOSE_FILE"
              else
                COMPOSE_FILE="docker-compose.prod.yml"
                echo "Using standard configuration: $COMPOSE_FILE"
              fi
            else
              # Fallback to simple validation
              COMPOSE_FILE="docker-compose.prod.yml"
              if [ -f .env.production ]; then
                if grep -q "^USE_SSL=true" .env.production 2>/dev/null; then
                  COMPOSE_FILE="docker-compose.ssl.yml"
                  echo "Using SSL configuration: $COMPOSE_FILE"
                fi
              fi
            fi

      - name: Health check and cleanup
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.ORACLE_CLOUD_SERVER_IP }}
          username: ${{ secrets.ORACLE_CLOUD_USER }}
          key: ${{ secrets.ORACLE_CLOUD_SSH_KEY }}
          timeout: 15m
          command_timeout: 15m
          script: |
            set -e  # Exit on any error
            cd /opt/bible-daily

            # Validate environment file and determine compose file
            if [ -f scripts/validate-env.sh ]; then
              # Use validation script if available
              chmod +x scripts/validate-env.sh
              ./scripts/validate-env.sh .env.production || echo "Environment validation completed with warnings"
              
              # Check SSL configuration using the script
              SSL_CONFIG=$(./scripts/validate-env.sh --check-ssl .env.production)
              if [ "$SSL_CONFIG" = "ssl" ]; then
                COMPOSE_FILE="docker-compose.ssl.yml"
                echo "Using SSL configuration: $COMPOSE_FILE"
              else
                COMPOSE_FILE="docker-compose.prod.yml"
                echo "Using standard configuration: $COMPOSE_FILE"
              fi
            else
              # Fallback to simple validation
              COMPOSE_FILE="docker-compose.prod.yml"
              if [ -f .env.production ]; then
                if grep -q "^USE_SSL=true" .env.production 2>/dev/null; then
                  COMPOSE_FILE="docker-compose.ssl.yml"
                  echo "Using SSL configuration: $COMPOSE_FILE"
                fi
              fi
            fi

            # Wait for services to be ready
            echo "‚è≥ Waiting for services to be ready..."
            sleep 60

            # Check backend health
            if [ '${{ needs.setup.outputs.deploy_backend }}' = 'true' ]; then
              for i in {1..10}; do
                if curl -f http://localhost:3000/health; then
                  echo '‚úÖ Backend health check passed'
                  break
                fi
                echo "Backend health check attempt $i failed, retrying in 10s..."
                sleep 10
              done
            fi

            # Check frontend health
            if [ '${{ needs.setup.outputs.deploy_frontend }}' = 'true' ]; then
              for i in {1..10}; do
                # Try HTTPS first if SSL is enabled, fallback to HTTP
                if [ "$USE_SSL" = "true" ]; then
                  if curl -f -k https://localhost:443 || curl -f http://localhost:80; then
                    echo '‚úÖ Frontend health check passed'
                    break
                  fi
                else
                  if curl -f http://localhost:80; then
                    echo '‚úÖ Frontend health check passed'
                    break
                  fi
                fi
                echo "Frontend health check attempt $i failed, retrying in 10s..."
                sleep 10
              done
            fi

            # Show final status
            docker-compose -f $COMPOSE_FILE ps
            docker system df

            # Cleanup old images to save disk space
            echo "üßπ Cleaning up old Docker images..."
            docker image prune -f

            # Remove old images (keep last 3 versions)
            docker images ${{ env.REGISTRY }}/${{ env.BACKEND_IMAGE_NAME }} --format 'table {{.Repository}}:{{.Tag}}\t{{.CreatedAt}}' | tail -n +4 | head -n -3 | awk '{print $1}' | xargs -r docker rmi || true
            docker images ${{ env.REGISTRY }}/${{ env.FRONTEND_IMAGE_NAME }} --format 'table {{.Repository}}:{{.Tag}}\t{{.CreatedAt}}' | tail -n +4 | head -n -3 | awk '{print $1}' | xargs -r docker rmi || true

            echo "‚úÖ Deployment completed successfully!"

  # Î∞∞Ìè¨ ÌõÑ ÌÜµÌï© ÌÖåÏä§Ìä∏
  post-deploy-tests:
    name: Post-deployment Integration Tests
    runs-on: ubuntu-latest
    needs: [setup, deploy-production]
    if: |
      always() && 
      needs.deploy-production.result == 'success' &&
      github.event.inputs.skip_tests != 'true' &&
      github.event.inputs.force_deploy != 'true'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup pnpm
        uses: pnpm/action-setup@v3
        with:
          version: ${{ env.PNPM_VERSION }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: "pnpm"

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Run production API tests
        run: pnpm --filter backend test:api
        env:
          API_BASE_URL: https://${{ secrets.ORACLE_CLOUD_SERVER_IP }}:3000
          CI: true
        continue-on-error: true

      - name: Upload test results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: production-test-results
          path: |
            backend/test-results/
            backend/coverage/

  # Î∞∞Ìè¨ ÏïåÎ¶º
  notify:
    name: Send Deployment Notifications
    runs-on: ubuntu-latest
    needs:
      [
        setup,
        build-backend,
        build-frontend,
        deploy-production,
        post-deploy-tests,
      ]
    if: always()
    steps:
      - name: Determine deployment status
        id: status
        run: |
          if [ "${{ needs.deploy-production.result }}" = "success" ]; then
            echo "status=success" >> $GITHUB_OUTPUT
            echo "color=good" >> $GITHUB_OUTPUT
            echo "emoji=‚úÖ" >> $GITHUB_OUTPUT
          elif [ "${{ needs.deploy-production.result }}" = "failure" ]; then
            echo "status=failure" >> $GITHUB_OUTPUT
            echo "color=danger" >> $GITHUB_OUTPUT
            echo "emoji=‚ùå" >> $GITHUB_OUTPUT
          else
            echo "status=cancelled" >> $GITHUB_OUTPUT
            echo "color=warning" >> $GITHUB_OUTPUT
            echo "emoji=‚ö†Ô∏è" >> $GITHUB_OUTPUT
          fi

      - name: Send Slack notification
        if: env.SLACK_WEBHOOK_URL != ''
        uses: 8398a7/action-slack@v3
        with:
          status: custom
          custom_payload: |
            {
              "text": "${{ steps.status.outputs.emoji }} Production Î∞∞Ìè¨ ${{ steps.status.outputs.status }}",
              "attachments": [
                {
                  "color": "${{ steps.status.outputs.color }}",
                  "fields": [
                    {
                      "title": "Environment",
                      "value": "Oracle Cloud ARM64 Production",
                      "short": true
                    },
                    {
                      "title": "Version",
                      "value": "${{ needs.setup.outputs.version }}",
                      "short": true
                    },
                    {
                      "title": "Services Deployed",
                      "value": "${{ needs.setup.outputs.deploy_backend == 'true' && 'Backend' || '' }} ${{ needs.setup.outputs.deploy_frontend == 'true' && 'Frontend' || '' }}",
                      "short": true
                    },
                    {
                      "title": "Deployment Type",
                      "value": "${{ github.event.inputs.force_deploy == 'true' && 'üö® Force Deploy' || (github.event.inputs.skip_tests == 'true' && '‚ö° Skip Tests' || '‚úÖ Normal') }}",
                      "short": true
                    },
                    {
                      "title": "SSL Configuration",
                      "value": "${{ github.event.inputs.use_ssl == 'true' && 'üîí HTTPS with Lets Encrypt' || 'üåê HTTP Only' }}",
                      "short": true
                    },
                    {
                      "title": "Branch",
                      "value": "${{ github.ref_name }}",
                      "short": true
                    },
                    {
                      "title": "Backend Image",
                      "value": "${{ needs.build-backend.outputs.image || 'Not deployed' }}",
                      "short": false
                    },
                    {
                      "title": "Frontend Image", 
                      "value": "${{ needs.build-frontend.outputs.image || 'Not deployed' }}",
                      "short": false
                    },
                    {
                      "title": "Commit",
                      "value": "<https://github.com/${{ github.repository }}/commit/${{ github.sha }}|${{ github.sha }}>",
                      "short": true
                    },
                    {
                      "title": "Actor",
                      "value": "${{ github.actor }}",
                      "short": true
                    }
                  ]
                }
              ]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

      - name: Create deployment summary
        run: |
          echo "## üöÄ Production Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Status:** ${{ steps.status.outputs.emoji }} ${{ steps.status.outputs.status }}" >> $GITHUB_STEP_SUMMARY
          echo "**Environment:** Oracle Cloud ARM64 Production" >> $GITHUB_STEP_SUMMARY
          echo "**Version:** ${{ needs.setup.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "**Branch:** ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
          echo "**Commit:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          if [ "${{ github.event.inputs.force_deploy }}" = "true" ]; then
            echo "**Deployment Type:** üö® **Force Deploy** (Î≥ÄÍ≤ΩÏÇ¨Ìï≠ Î¨¥Ïãú)" >> $GITHUB_STEP_SUMMARY
          elif [ "${{ github.event.inputs.skip_tests }}" = "true" ]; then
            echo "**Deployment Type:** ‚ö° **Skip Tests** (ÌÖåÏä§Ìä∏ Í±¥ÎÑàÎúÄ)" >> $GITHUB_STEP_SUMMARY
          else
            echo "**Deployment Type:** ‚úÖ **Normal** (Ï†ïÏÉÅ Î∞∞Ìè¨)" >> $GITHUB_STEP_SUMMARY
          fi
          if [ "${{ github.event.inputs.use_ssl }}" = "true" ]; then
            echo "**SSL Configuration:** üîí **HTTPS with Lets Encrypt**" >> $GITHUB_STEP_SUMMARY
          else
            echo "**SSL Configuration:** üåê **HTTP Only**" >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Services Deployed" >> $GITHUB_STEP_SUMMARY
          if [ "${{ needs.setup.outputs.deploy_backend }}" = "true" ]; then
            echo "- ‚úÖ **Backend:** ${{ needs.build-backend.outputs.image }}" >> $GITHUB_STEP_SUMMARY
          else
            echo "- ‚è≠Ô∏è **Backend:** Not deployed" >> $GITHUB_STEP_SUMMARY
          fi
          if [ "${{ needs.setup.outputs.deploy_frontend }}" = "true" ]; then
            echo "- ‚úÖ **Frontend:** ${{ needs.build-frontend.outputs.image }}" >> $GITHUB_STEP_SUMMARY
          else
            echo "- ‚è≠Ô∏è **Frontend:** Not deployed" >> $GITHUB_STEP_SUMMARY
          fi
