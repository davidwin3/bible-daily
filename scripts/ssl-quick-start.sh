#!/bin/bash

# Quick Start Script for Let's Encrypt SSL Setup
# This script provides an interactive setup for SSL certificates

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Configuration
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(dirname "$SCRIPT_DIR")"
ENV_FILE="$PROJECT_ROOT/.env"

# Functions
log_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

log_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

log_step() {
    echo -e "${CYAN}[STEP]${NC} $1"
}

# Welcome message
show_welcome() {
    echo -e "${GREEN}"
    echo "╔══════════════════════════════════════════════════════════════╗"
    echo "║                    Bible Daily SSL Setup                    ║"
    echo "║              Let's Encrypt 자동 인증서 발급                  ║"
    echo "╚══════════════════════════════════════════════════════════════╝"
    echo -e "${NC}"
    echo
}

# Collect user input
collect_domain_info() {
    log_step "도메인 정보 입력"
    echo
    
    # Primary domain
    while true; do
        read -p "주 도메인을 입력하세요 (예: bible-daily.com): " DOMAIN
        if [[ $DOMAIN =~ ^[a-zA-Z0-9][a-zA-Z0-9-]{1,61}[a-zA-Z0-9]\.[a-zA-Z]{2,}$ ]]; then
            break
        else
            log_error "올바른 도메인 형식을 입력해주세요."
        fi
    done
    
    # Additional domains
    echo
    log_info "추가 도메인을 입력하세요 (선택사항)"
    log_info "여러 도메인은 쉼표로 구분하세요 (예: www.bible-daily.com,api.bible-daily.com)"
    read -p "추가 도메인 (Enter로 건너뛰기): " ADDITIONAL_DOMAINS
    
    # Email
    echo
    while true; do
        read -p "Let's Encrypt 알림용 이메일: " CERTBOT_EMAIL
        if [[ $CERTBOT_EMAIL =~ ^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$ ]]; then
            break
        else
            log_error "올바른 이메일 형식을 입력해주세요."
        fi
    done
    
    # Staging option
    echo
    log_info "테스트 환경을 사용하시겠습니까? (권장: 처음 설정 시 'y')"
    log_warning "테스트 환경은 인증서 발급 제한이 없지만, 브라우저에서 신뢰되지 않습니다."
    read -p "테스트 환경 사용 (y/N): " use_staging
    
    if [[ $use_staging =~ ^[Yy]$ ]]; then
        CERTBOT_STAGING=1
        log_warning "테스트 환경을 사용합니다."
    else
        CERTBOT_STAGING=0
        log_info "운영 환경을 사용합니다."
    fi
}

# Show configuration summary
show_summary() {
    echo
    log_step "설정 요약"
    echo
    echo -e "${CYAN}주 도메인:${NC} $DOMAIN"
    if [ ! -z "$ADDITIONAL_DOMAINS" ]; then
        echo -e "${CYAN}추가 도메인:${NC} $ADDITIONAL_DOMAINS"
    fi
    echo -e "${CYAN}이메일:${NC} $CERTBOT_EMAIL"
    echo -e "${CYAN}환경:${NC} $([ $CERTBOT_STAGING -eq 1 ] && echo "테스트" || echo "운영")"
    echo
    
    read -p "위 설정으로 진행하시겠습니까? (Y/n): " confirm
    if [[ $confirm =~ ^[Nn]$ ]]; then
        log_info "설정을 취소합니다."
        exit 0
    fi
}

# Create .env file
create_env_file() {
    log_step ".env 파일 생성"
    
    # Backup existing .env file
    if [ -f "$ENV_FILE" ]; then
        cp "$ENV_FILE" "$ENV_FILE.backup.$(date +%Y%m%d_%H%M%S)"
        log_info "기존 .env 파일을 백업했습니다."
    fi
    
    # Create new .env file
    cat > "$ENV_FILE" << EOF
# Bible Daily Configuration
# Generated by ssl-quick-start.sh on $(date)

# SSL Configuration with Let's Encrypt
DOMAIN=$DOMAIN
$([ ! -z "$ADDITIONAL_DOMAINS" ] && echo "ADDITIONAL_DOMAINS=$ADDITIONAL_DOMAINS")

# Let's Encrypt Configuration
CERTBOT_EMAIL=$CERTBOT_EMAIL
CERTBOT_STAGING=$CERTBOT_STAGING

# SSL Certificate Paths (automatically managed by Let's Encrypt)
SSL_CERT_PATH=/etc/letsencrypt/live/$DOMAIN/fullchain.pem
SSL_KEY_PATH=/etc/letsencrypt/live/$DOMAIN/privkey.pem
USE_LETSENCRYPT=true

# Database Configuration (update these values)
DB_ROOT_PASSWORD=your_secure_root_password
DB_USERNAME=bible_user
DB_PASSWORD=your_secure_password
DB_DATABASE=bible_daily
DB_PORT=3306

# Redis Configuration
REDIS_PASSWORD=your_secure_redis_password
REDIS_PORT=6379

# JWT Configuration
JWT_SECRET=your_super_secret_jwt_key_here
JWT_REFRESH_SECRET=your_super_secret_refresh_key_here

# Firebase Configuration (update these values)
FIREBASE_PROJECT_ID=your-project-id
FIREBASE_PRIVATE_KEY_ID=your-private-key-id
FIREBASE_PRIVATE_KEY=your-private-key
FIREBASE_CLIENT_EMAIL=your-client-email
FIREBASE_CLIENT_ID=your-client-id

# CORS Configuration
CORS_ORIGIN=https://$DOMAIN

# Build Configuration
FRONTEND_IMAGE=ghcr.io/davidwin3/bible-daily/frontend:latest
BACKEND_IMAGE=ghcr.io/davidwin3/bible-daily/backend:latest
BUILD_VERSION=latest
EOF
    
    log_success ".env 파일이 생성되었습니다."
    log_warning "데이터베이스, Redis, JWT, Firebase 설정을 업데이트해주세요."
}

# Check prerequisites
check_prerequisites() {
    log_step "시스템 요구사항 확인"
    
    # Check if running as root
    if [[ $EUID -ne 0 ]]; then
        log_error "이 스크립트는 root 권한으로 실행해야 합니다. (sudo 사용)"
        exit 1
    fi
    
    # Check Docker
    if ! command -v docker &> /dev/null; then
        log_error "Docker가 설치되지 않았습니다."
        exit 1
    fi
    
    # Check Docker Compose
    if ! command -v docker-compose &> /dev/null; then
        log_error "Docker Compose가 설치되지 않았습니다."
        exit 1
    fi
    
    # Check DNS resolution
    log_info "DNS 해상도 확인 중..."
    if ! nslookup "$DOMAIN" &> /dev/null; then
        log_warning "도메인 '$DOMAIN'의 DNS 해상도를 확인할 수 없습니다."
        log_warning "도메인이 이 서버의 IP를 가리키는지 확인해주세요."
        read -p "계속 진행하시겠습니까? (y/N): " continue_anyway
        if [[ ! $continue_anyway =~ ^[Yy]$ ]]; then
            exit 1
        fi
    else
        log_success "DNS 해상도 확인 완료"
    fi
    
    log_success "시스템 요구사항 확인 완료"
}

# Run SSL setup
run_ssl_setup() {
    log_step "SSL 설정 실행"
    
    cd "$PROJECT_ROOT"
    
    if [ -f "./scripts/ssl-setup.sh" ]; then
        log_info "SSL 설정 스크립트를 실행합니다..."
        ./scripts/ssl-setup.sh
    else
        log_error "SSL 설정 스크립트를 찾을 수 없습니다."
        exit 1
    fi
}

# Show next steps
show_next_steps() {
    echo
    log_success "SSL 설정이 완료되었습니다! 🎉"
    echo
    log_step "다음 단계"
    echo
    echo "1. 서비스 상태 확인:"
    echo "   docker-compose -f docker-compose.ssl.yml ps"
    echo
    echo "2. SSL 인증서 상태 확인:"
    echo "   ./scripts/ssl-status.sh"
    echo
    echo "3. 웹사이트 접속:"
    echo "   https://$DOMAIN"
    if [ ! -z "$ADDITIONAL_DOMAINS" ]; then
        for domain in $(echo "$ADDITIONAL_DOMAINS" | tr ',' ' '); do
            domain=$(echo "$domain" | xargs)
            echo "   https://$domain"
        done
    fi
    echo
    echo "4. 로그 확인:"
    echo "   docker-compose -f docker-compose.ssl.yml logs -f"
    echo
    
    if [ $CERTBOT_STAGING -eq 1 ]; then
        log_warning "테스트 환경을 사용했습니다."
        log_info "운영 환경으로 전환하려면:"
        echo "   1. .env 파일에서 CERTBOT_STAGING=0으로 변경"
        echo "   2. docker-compose -f docker-compose.ssl.yml down"
        echo "   3. sudo rm -rf /opt/bible-daily/ssl/letsencrypt/live/$DOMAIN"
        echo "   4. docker-compose -f docker-compose.ssl.yml up -d"
    fi
    
    echo
    log_info "문제가 발생하면 다음 명령어로 트러블슈팅하세요:"
    echo "   ./scripts/ssl-status.sh"
    echo "   docker-compose -f docker-compose.ssl.yml logs certbot"
}

# Main function
main() {
    show_welcome
    collect_domain_info
    show_summary
    check_prerequisites
    create_env_file
    run_ssl_setup
    show_next_steps
}

# Show usage
usage() {
    echo "Usage: $0 [OPTIONS]"
    echo ""
    echo "Options:"
    echo "  -h, --help     Show this help message"
    echo "  --non-interactive  Run in non-interactive mode (requires env vars)"
    echo ""
    echo "Environment variables for non-interactive mode:"
    echo "  DOMAIN                Primary domain"
    echo "  ADDITIONAL_DOMAINS    Additional domains (comma-separated)"
    echo "  CERTBOT_EMAIL         Email for Let's Encrypt"
    echo "  CERTBOT_STAGING       Use staging environment (0 or 1)"
}

# Parse command line arguments
INTERACTIVE=true

while [[ $# -gt 0 ]]; do
    case $1 in
        -h|--help)
            usage
            exit 0
            ;;
        --non-interactive)
            INTERACTIVE=false
            shift
            ;;
        *)
            log_error "Unknown option: $1"
            usage
            exit 1
            ;;
    esac
done

# Run main function
if [ "$INTERACTIVE" = true ]; then
    main "$@"
else
    # Non-interactive mode
    if [ -z "$DOMAIN" ] || [ -z "$CERTBOT_EMAIL" ]; then
        log_error "Non-interactive mode requires DOMAIN and CERTBOT_EMAIL environment variables"
        exit 1
    fi
    
    CERTBOT_STAGING=${CERTBOT_STAGING:-0}
    create_env_file
    check_prerequisites
    run_ssl_setup
    show_next_steps
fi
